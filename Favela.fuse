--[[--/*

    Favela.fuse

    Based on https://www.shadertoy.com/view/ldGcDh a WebGL
    shader from shadertoy.com converted to DCTL and embeddet
    into a Lua Fuse by nmbr73 (https://www.youtube.com/c/nmbr73)
    for use in DaFusion.

    Shader created by duvengar

    Favela by Julien Vergnaud @duvengar-2018
    License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
    Based on the Minimal Hexagonal Grid example from @Shane.
    Minimal Hexagonal Grid - Shane
    https://www.shadertoy.com/view/Xljczw



    === STATUS ===

    runs      on macOS / Metal
    CRASHES!  on macOS / OpenCL

    ... and it has some incosistencies (grass on the walls and such)

*/--]]--

-- "LUA CODE..." /**

local shadertoy_name       = "Favela"
local shadertoy_author     = "duvengar"
local shadertoy_id         = "ldGcDh"
local shadertoy_license    = "Favela by Julien Vergnaud @duvengar-2018 (CC BY-NC-SA 3.0)"
local dctlfuse_code        = true
local dctlfuse_name        = "Favela"
local dctlfuse_author      = "nmbr73"
local dctlfuse_authorurl   = "https://www.youtube.com/c/nmbr73"
local dctlfuse_infourl     = "https://nmbr73.github.io/Shadertoys/"
local dctlfuse_versionNo   = 1
local dctlfuse_versionDate = ""





-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------

FuRegisterClass("ST_"..dctlfuse_name, CT_SourceTool, {
  REGS_Category          = "Fuses\\Shadertoys",
  REGS_OpIconString      = "ST-"..shadertoy_id,
  REGS_OpDescription     = "Shadertoy '"..shadertoy_name.."' (ID: "..shadertoy_id..")",

  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,

  REG_Source_GlobalCtrls = false,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  REG_OpNoMask           = true,
  REG_Fuse_NoEdit        = not(dctlfuse_code),
  REG_Fuse_NoReload      = not(dctlfuse_code),

  REG_TimeVariant        = true,

  REGS_Company           = dctlfuse_author,
  REGS_URL               = dctlfuse_authorurl,
  REG_Version            = dctlfuse_versionNo,
  })



-- // ------------------------------------------------------------------------
-- // DCTL general compability code
-- // ------------------------------------------------------------------------

-- **/ "End of LUA CODE"

local GLSL_CompabilityCode=[[

// 0 to use the generic implementations; 1 for Metal, OpenCL, Cuda specific code if existing
#define USE_DEVICE_NATIVE_IMPLEMENTATION 1

// In Cuda the fract function is missing
#ifdef DEVICE_IS_CUDA
  __DEVICE__ float fract1f(float f) {return f - _floor(f);}
#endif

#ifdef DEVICE_IS_METAL
  __DEVICE__ float fract1f(float f) {return fract(f);}
#endif



#if defined(DEVICE_IS_METAL) && USE_DEVICE_NATIVE_IMPLEMENTATION
  __DEVICE__ inline float2 fract_float2(float2 v) { return fract(v); }
  __DEVICE__ inline float3 fract_float3(float3 v) { return fract(v); }
#else
  __DEVICE__ float2 fract_float2(float2 v) { return to_float2(v.x - _floor(v.x), v.y - _floor(v.y)); }
  __DEVICE__ float3 fract_float3(float3 v) { return to_float3(v.x - _floor(v.x), v.y - _floor(v.y), v.z - _floor(v.z)); }
#endif



// @tida : did you fin out if you need to build a function for length?!?
// See https://www.steakunderwater.com/wesuckless/viewtopic.php?p=35549&sid=c4b440f6caff5fb5e24d0318a0a36bdb#p35549
// However, I need length and don't know if there is a differently named implementation in DCTL:

  __DEVICE__ inline float length1f (float x                            ) { return x;                        }
//__DEVICE__ inline float length2f (float x, float y                   ) { return _sqrtf(x*x+y*y);          }
//__DEVICE__ inline float length3f (float x, float y, float z          ) { return _sqrtf(x*x+y*y+z*z);      }
//__DEVICE__ inline float length4f (float x, float y, float z, float w ) { return _sqrtf(x*x+y*y+z*z+w*w);  }

//__DEVICE__ inline float length_float  ( float  v ) { return v;                                        }
  __DEVICE__ inline float length_float2 ( float2 v ) { return _sqrtf(v.x*v.x+v.y*v.y);                  }
//__DEVICE__ inline float length_float3 ( float3 v ) { return _sqrtf(v.x*v.x+v.y*v.y+v.z*v.z);          }
//__DEVICE__ inline float length_float4 ( float4 v ) { return _sqrtf(v.x*v.x+v.y*v.y+v.z*v.z+v.w*v.w);  }

// Don't know if a to_float4_??(float2,float2) exists?!?

//__DEVICE__ inline float4 to_float4_31( float3 a, float b ) { return to_float4_aw(a,b);       }
//__DEVICE__ inline float4 to_float4_13( float  a, float3 b) { return float4(a,b.x,b.y,b.z  ); }
  __DEVICE__ inline float4 to_float4_22( float2 a, float2 b) { return float4(a.x,a.y,b.x,b.y); } //float4 t(a.x,a.y,b.x,b.y); return t;




// Our 2x2 matrix

#if defined(DEVICE_IS_METAL) && USE_DEVICE_NATIVE_IMPLEMENTATION

  typedef float2x2 mat2;

    __DEVICE__ inline mat2 to_mat2_4f ( float  a, float  b, float c, float d) { return mat2(a,b,c,d);       }
  //__DEVICE__ inline mat2 to_mat2_1f ( float  a                            ) { return mat2(a,a,a,a);       }
  //__DEVICE__ inline mat2 to_mat2_s  ( float  a                            ) { return mat2(a);             }
  //__DEVICE__ inline mat2 to_mat2_22 ( float2 a, float2 b                  ) { return mat2(a,b);           }
  //__DEVICE__ inline mat2 to_mat2_13 ( float  a, float3 b                  ) { return mat2(a,b.x,b.y,b.z); }
  //__DEVICE__ inline mat2 to_mat2_31 ( float3 a, float  b                  ) { return mat2(a.x,a.y,a.z,b); }

    __DEVICE__ inline mat2    prod_mat2_mat2  ( mat2   a, mat2   b )  { return a*b; }
    __DEVICE__ inline float2  prod_float2_mat2( float2 v, mat2   m )  { return v*m; }
    __DEVICE__ inline float2  prod_mat2_float2( mat2   m, float2 v )  { return m*v; }
    __DEVICE__ inline mat2    prod_mat2_1f    ( mat2   m, float  s )  { return m*s; }
  //__DEVICE__ inline mat2    prod_1f_mat2    ( float  s, mat2   m )  { return s*m; }

#else

  typedef struct
  {
    float2 r0;
    float2 r1;

  } mat2;

    __DEVICE__ inline mat2 to_mat2_4f ( float  a, float  b, float c, float d)  { mat2 t; t.r0.x = a; t.r0.y = b; t.r1.x = c; t.r1.y = d;         return t; }
  //__DEVICE__ inline mat2 to_mat2_1f ( float  a                            )  { mat2 t; t.r0.x = a; t.r0.y = a; t.r1.x = a; t.r1.y = a;         return t; }
  //__DEVICE__ inline mat2 to_mat2_s  ( float  a                            )  { mat2 t; t.r0.x = a;  t.r0.y = 0.0f; t.r1.x = 0.0f; t.r1.y = a;  return t; }
  //__DEVICE__ inline mat2 to_mat2_22 ( float2 a, float2 b                  )  { mat2 t; t.r0 = a; t.r1 = b;                                     return t; }
  //__DEVICE__ inline mat2 to_mat2_13 ( float  a, float3 b                  )  { mat2 t; t.r0.x = a; t.r0.y = b.x; t.r1.x = b.y; t.r1.y = b.z;   return t; }
  //__DEVICE__ inline mat2 to_mat2_31 ( float3 a, float  b                  )  { mat2 t; t.r0.x = a.x; t.r0.y = a.y; t.r1.x = a.z; t.r1.y = b;   return t; }


  __DEVICE__ inline mat2 prod_mat2_mat2( mat2 a, mat2 b)
  {
    mat2 t;
    t.r0.x = a.r0.x * b.r0.x + a.r0.y * b.r1.x;   t.r0.y = a.r0.x * b.r0.y + a.r0.y * b.r1.y;
    t.r1.x = a.r1.x * b.r0.x + a.r1.y * b.r1.x;   t.r1.y = a.r1.x * b.r0.y + a.r1.y * b.r1.y;
    return t;
  }


  __DEVICE__ inline float2 prod_float2_mat2( float2 v, mat2 m )
  {
    float2 t; t.x = v.x*m.r0.x + v.y*m.r0.y; t.y = v.x*m.r1.x + v.y*m.r1.y; return t;
    // return float2(v.x*m.r0.x + v.y*m.r0.y, v.x*m.r1.x + v.y*m.r1.y);
  }


  __DEVICE__ inline float2 prod_mat2_float2( mat2 m, float2 v )
  {
    float2 t; t.x = v.x*m.r0.x + v.y*m.r1.x; t.y = v.x*m.r0.y + v.y*m.r1.y; return t;
    // return float2(v.x*m.r0.x + v.y*m.r1.x, v.x*m.r0.y + v.y*m.r1.y);
  }


  __DEVICE__ inline mat2 prod_mat2_1f( mat2 m, float s)
  {
    mat2 t;
    t.r0.x = s * m.r0.x;
    t.r0.y = s * m.r0.y;
    t.r1.x = s * m.r1.x;
    t.r1.y = s * m.r1.y;
    return t;
  }

  //__DEVICE__ inline mat2 prod_1f_mat2( float s, mat2 m) { return prod_mat2_1f(m,s); }

#endif // end of mat2 implementation

]]



-- // ------------------------------------------------------------------------
-- // DCTL kernel parameters
-- // ------------------------------------------------------------------------

ST_FavelaParams =
[[
  int   compOrder;
  int   width;
  int   height;
  float iTime;

  float freq;
  float SIZE;
  int   Suntime;
  float Sunshine;
]]



-- // ------------------------------------------------------------------------
-- // DCTL kernel implementation
-- // ------------------------------------------------------------------------

ST_FavelaKernel =
    [[

///////////////////////////////////////////////////////////////////////////////////////////////////


__DEVICE__ float hash2(float2 p)
{
  // hash2 taken from Dave Hoskins
  // https://www.shadertoy.com/view/4djSRW

  float3 p3  = fract_float3(p.xyx * 0.2831f);
  p3 += dot(p3, p3.yzx + 19.19f);
  return fract1f((p3.x + p3.y) * p3.z);

  //float3 p3  = fract_float3(  to_float3(p.x,p.y,p.x) * 0.2831f);
  //p3 += dot(p3, to_float3(p3.y,p3.z,p3.x) + 19.19f);
  //return fract1f((p3.x + p3.y) * p3.z);
}


__DEVICE__ float hash(float n)
{
  return fract1f(_sinf(n)*43758.5453123f);
}


__DEVICE__ float noise(float2 x)
{
  float2 p = floor(x);
  float2 f = fract_float2(x);
  f = f * f * (3.0f - 2.0f * f);
  float n = p.x + p.y * 57.0f;
  return mix(mix(hash(n + 0.0f), hash(n + 1.0f), f.x), mix(hash(n + 57.0f), hash(n + 58.0f), f.x), f.y);
}


__DEVICE__ float fbm(float2 p)
{
  // see iq
  // https://www.shadertoy.com/view/lsfGRr

  const mat2 m = to_mat2_4f( 0.6f, 0.6f, -0.6f, 0.8f);

  float f = 0.0f;
  f += 0.5000f * noise(p); p = prod_float2_mat2(p,prod_mat2_1f(m, 2.02f));
  f += 0.2500f * noise(p); p = prod_float2_mat2(p,prod_mat2_1f(m, 2.03f));
  f += 0.1250f * noise(p); p = prod_float2_mat2(p,prod_mat2_1f(m, 2.01f));
  f += 0.0625f * noise(p); p = prod_float2_mat2(p,prod_mat2_1f(m, 2.04f));
  f /= 0.9375f;
  return f;
}

///////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef DEVICE_IS_METAL

  constant float2 s = to_float2(1.0f, 1.7320508f);

#elif defined(DEVICE_IS_OPENCL)

  #define s (to_float2(1.0f, 1.7320508f)) // okay, das ist hart, aber was will man machen?!?

#else

  const float2 s = to_float2(1.0f, 1.7320508f);

#endif




__DEVICE__ float hex(float2 p)
{
  p = _fabs(p);
  return _fmaxf(dot(p, s *0.5f), p.x );
}


__DEVICE__ float4 getHex(float2 p)
{

  float4 hC = floor(to_float4_22(p, p - to_float2(0.5f, 1.0f)) / s.xyxy) + 0.5f;
  float4 h = to_float4_22(p - hC.xy*s, p - (hC.zw + 0.5f)*s);
  return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? to_float4_22(h.xy, hC.xy) : to_float4_22(h.zw, hC.zw + to_float2(0.5f, 1.0f));
}



/////////////////////////////////////////////////////////////////////////////////////////////////////


#define M(a)        to_mat2_4f(_cosf(a), -_sinf(a), _sinf(a), _cosf(a))
#define S(a, b, c)  smoothstep(a, b, c)
#define SAT(a)      _clampf(a, 0.0f, 1.0f)
#define T           iTime

#define PI M_PI                 // do all systems use math.h?
//#define PI 3.14159265358979f  // we could do this, if we don't have M_PI
//#define PI _acosf(-1.0f)      // that's what had been used in the shadertoy

#define TWO_PI (PI * 2.0f)

//#define SIZE 0.4f
#define BLUR 0.02f


__DEVICE__ float rem(float2 iR)
{
    float slices = 10.0f * floor(iR.y / 50.0f); // 50.0f = LOWRES
    return  _sqrtf(slices);
}


__DEVICE__ float stripes( float2 uv, mat2 rot, float num, float amp, float blr)
{
    uv = prod_float2_mat2(uv,rot); // uv *= rot;
    // uv *= M(.02);
    float h =  smoothstep(amp+blr, amp - blr,  length1f(fract1f(uv.x * num )-0.5f));
    return h;
}

__DEVICE__ float dfDiamond(float2 h)
{
    h *= s; // rescale diamond verticaly with the helper vector
    float2 p =  to_float2(_fabs(h.x), _fabs(h.y));
    float d = (p.x+p.y)/0.5f;
    //return S(.2,.9,length(d));
    return d;
}


__DEVICE__ float rect(float2 uv,float2 p, float w, float h, float b)
{
    uv += p;
    float rv = S(h, h + b, length1f(uv.x));
    float rh = S(w, w + b, length1f(uv.y));
    return rv + rh;
}

//#ifdef DEVICE_IS_OPENCL
//  #undef s
//#endif


//############################################################################

__KERNEL__ void ST_FavelaKernel(
    __CONSTANTREF__ ST_FavelaParams*  params,
    __TEXTURE2D__                     iChannel0,
    __TEXTURE2D_WRITE__               dst
    )
{

  DEFINE_KERNEL_ITERATORS_XY(x, y);

  if (x >= params->width || y >= params->height)
    return;

  // ----- Standard parameters
  float2 fragCoord   = to_float2(x, y);
  float2 iResolution = to_float2(params->width, params->height);
  float  iTime       = params->iTime * params->freq;
  float4 fragColor   = to_float4_s(0.0f);

  // ----- Additional parameters
  float SIZE        = params->SIZE;
  float Sunshine    = params->Sunshine;
  int   Suntime     = params->Suntime;

  //##########################################################################

  //  set up pixel coord
  //  ------------------
  float2 uv = (2.0f * fragCoord - iResolution.xy) / iResolution.y;            // [nmbr73] or just iResolution without .xy?
  uv = prod_float2_mat2(uv,M(0.25f * _cosf(PI) * 0.5f * length_float2(uv)));  // twist the pixels domain
  uv *= 1.1f;                                                                 // scale up the pixels domain
  uv = prod_float2_mat2(uv,M(PI));                                            // rotate the pixels domain
  uv *= 0.8f+dot(uv*0.3f,uv*0.3f);                                            // length distortion


  //  ------------------------------------------------------------------------------------------------
  //  variables
  //  ------------------------------------------------------------------------------------------------
  float   motion  = 325.543f + T * 0.5f;		            // speed
  float   SCALE   = rem(iResolution.xy)*SIZE;           // screen rescaling ratio

  // three options for the initialisation of the blur value were given
  // in the original shadertoy. But the one actually used there does not
  // work in DCTL without further changes to substitute fwidth() ...
  //float   blr     = BLUR;
  //float   blr     = fwidth(uv.x)*length(uv)*8.0f;     // blur value
  float   blr     = S(0.0f,1.0f,length_float2(uv)*0.13f);
  float2  pos     = uv - motion;                        // position
  float3  lights  = to_float3_s(0.0f);
  float3  blights = to_float3_s(0.0f);
//float   sun     = _cosf(T*0.3f);
  float   sun = _cosf( (Suntime?T:PI)   * Sunshine);

  //  Hexagons grid
  //  -------------

  float4  h       = getHex( pos + SCALE * uv + s.yx);   // hexagons center
  float   eDist   = hex(h.xy);                          // hexagone Edge distance.
  float   eDist2  = hex(h.xy + to_float2(0.0f,0.25f));
  //float   cDist   = length_float2(h.xy);                // @Shane: cDist = dot(h.xy, h.xy);

#ifdef DEVICE_IS_OPENCL
  float tilt = 0.0f;    // @TODO !!!!!
#else
  float   tilt    = hash2(h.zw*2376.345791f); // random value depending on cel ids
#endif

  //  ------------------------------------------------------------------------------------------------
  //  sorting the hexagons
  //  ------------------------------------------------------------------------------------------------

  //  hexagons states booleans
  //  ------------------------
  float hills = 0.0f;
  float red   = 0.0f;
  float flip  = 0.0f;
  float empty = 0.0f;
  float tex   = 0.0f;
  float wnds  = 0.0f;
  float tree  = 0.0f;
  float doors = 0.0f;

  //  wich tile are flipped?
  //  ----------------------
  float ff = _cosf(5.0f * _sinf(h.z - h.w)*tilt);
  if (ff > 0.0f)
  {
    flip = 1.0f;
    h.xy = prod_float2_mat2(h.xy,M(PI)); // does swizzling work on all platforms

    empty = ff > 0.99f ? 1.0f : 0.0f;
  }


  //  polar coordinates + cubes faces angles
  //  --------------------------------------
  float2 pol = to_float2(_atan2f(h.x, h.y) / TWO_PI + 0.5f, length_float2(uv));
  float2 ang = to_float2(0.333333f, 0.666666f);

  if (pol.x <=  ang.x || tilt >= 0.7f)
  {
    wnds = 1.0f;

    if(tilt >=0.9f)
      doors = 1.0f;
  }

  //  wich tiles are hills?
  //  ---------------------

#ifndef DEVICE_IS_OPENCL // @TODO !!!!

  if (flip == 0.0f && noise(h.zw)*0.5f > 0.3f)
  {
    hills = 1.0f;
    tree = tilt > 0.5f ? 1.0f : 0.0f;
  }
#endif


  //  ------------------------------------------------------------------------------------------------
  //  create the windows elements
  //  ------------------------------------------------------------------------------------------------

  float2 pat  = h.xy;                                                                             // original position (up lozenge in the hexagon)
  float2 pat2 = h.xy-(to_float2(flip == 1.0f ? 0.05f : -0.05, flip == 1.0f ? 0.03f : - 0.03f));   // offseted and rotated position on the right side
  float2 pat3 = h.xy-(to_float2(flip == 0.0f ? 0.05f : -0.05, flip == 1.0f ? 0.05f : - 0.05f));   // offseted and rotated position on the left side


  float s1  = stripes(pat,  prod_mat2_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 2.0f: 4.0f, 0.3f, blr );  // vertical stripes
  float s2  = stripes(pat,  prod_mat2_mat2(M(TWO_PI*0.666f),  M(0.02f)), 4.0f, 0.3f, blr );                       // oriented stripes

  float s3  = stripes(pat,  prod_mat2_mat2(M(TWO_PI*0.333f),  M(0.02f)), 4.0f, 0.3f, blr );
  float s4  = stripes(pat,  prod_mat2_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 4.0f: 2.0f, 0.3f, blr );

  float m1  = stripes(pat2, prod_mat2_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 2.0f: 4.0f, 0.3f, blr );
  float m2  = stripes(pat2, prod_mat2_mat2(M(TWO_PI*0.333f ), M(0.02f)), 4.0f, 0.3f, blr );

  float ml1 = stripes(pat3, prod_mat2_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 4.0f: 4.0f, 0.3, blr );
  float ml2 = stripes(pat3, prod_mat2_mat2(M(TWO_PI*0.666f),  M(0.02f)), 4.0f, 0.3f, blr );

  float windowsR  = min(s1,s3);                     // windows on the Right side
  float windowsL  = min(s4,s2);                     // windows on the Left side

  float maskR     = min(m1,m2);                     // offseted Right windows
  float maskL     = min(ml1,ml2);                   // offseted Left windows

  float winnerR   = min(windowsR, maskR);           // cuted Right inner windows
  float winnerL   = min(windowsL, maskL);           // cuted Left inner windows

  float wbevelR   = min(windowsR,windowsR-winnerR); // cuted Right bevel
  float wbevelL   = min(windowsL,windowsL-winnerL); // cuted Left bevels


  //  blured windows
  //  --------------

  float blr2  = BLUR * 8.;

  float bs1   = stripes(pat,  prod_mat2_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 2.0f: 4.0f, 0.3f, blr2 );   // vertical stripes
  float bs2   = stripes(pat,  prod_mat2_mat2(M(TWO_PI*0.666f),  M(0.02f)), 4.0f, 0.3f, blr2 );                        // oriented stripes

  float bs3   = stripes(pat,  prod_mat2_mat2(M(TWO_PI*0.333f ), M(0.02f)), 4.0f, 0.3f, blr2 );
  float bs4   = stripes(pat,  prod_mat2_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 4.0f: 2.0f, 0.3f, blr2 );

  float bm1   = stripes(pat2, prod_mat2_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 2.0f: 4.0f, 0.3f, blr2 );
  float bm2   = stripes(pat2, prod_mat2_mat2(M(TWO_PI*0.333f ), M(0.02f)), 4.0f, 0.3f, blr2 );

  float bml1  = stripes(pat3, prod_mat2_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 4.0f: 4.0f, 0.3f, blr2 );
  float bml2  = stripes(pat3, prod_mat2_mat2(M(TWO_PI*0.666f),  M(0.02f)), 4.0f, 0.3f, blr2 );

  float bwindowsR = min(bs1,bs3);             // windows on the Right side
  float bwindowsL = min(bs4,bs2);             // windows on the Left side

  float bmaskR    = min(bm1,bm2);             // offseted Right windows
  float bmaskL    = min(bml1,bml2);           // offseted Left windows

  float bwinnerR  = min(bwindowsR, bmaskR);   // cuted Right inner windows
  float bwinnerL  = min(bwindowsL, bmaskL);   // cuted Left inner windows

  //  ------------------------------------------------------------------------------------------------
  //  shading the cubes faces
  //  ------------------------------------------------------------------------------------------------

  //  noise texture
  //  -------------
  float3 col = to_float3_s(1.0f);
  float n1 = 0.5f-(fbm(((uv -motion*0.24f)* 20.0f)));
  float n2 = 0.5f-(fbm(((uv -motion*0.31f)* 5.0f)));
  col += 0.4f * (max(n1,n2));


  //  painting
  //  --------
  float3 paint = to_float3(_cosf(h.z + h.w *0.2f),_cosf(tilt)*0.3f,noise(h.zw));

  //  lightning
  //  ---------
  float2 facespos = h.xy;
  facespos = prod_float2_mat2(facespos, M(TWO_PI*ang.x));

  float2 fa = facespos;
  float shw = 0.7f * S(1.1f+ blr, 1.0f-blr, dfDiamond(facespos - (to_float2(0.0f, 0.3f))));
  facespos = prod_float2_mat2(facespos,M(TWO_PI*ang.x));

  float2 fb = facespos;
  shw += 0.2f * S(1.1f+blr, 1.0f-blr, dfDiamond(facespos - (to_float2(0.0f, 0.3f))));
  col -= shw;


  float fao = _clampf(smoothstep(1.0f,0.0f,eDist), 0.0f, 1.0f);               // Fake lightning gradient
  //fao = hills == 1. ? fao * 1.5 : fao;
  fao = flip == 0.0f || empty == 0.1f ?  0.65f * fao :  0.65f * (1.0f-fao);   // apply it as a shadow or light on the cubes
  col -= fao;
  col = mix(col,to_float3(0.7f,0.3f,0.0f),0.45f);


  //  face 01 (right)
  //  --------------
  if(pol.x <=  ang.x )
  {
    if ( hills == 0.0f)
    {
              col      = tilt > 0.2f  ? col :  col +0.3f * paint ;
      float2  dir      = cos(T + h.z) > 0.0f ? prod_mat2_float2(M(PI/3.0f),h.xy) : -prod_mat2_float2(M(PI/3.0f),h.xy); // was: -M(PI/3.0f)*h.xy;
      float   blink    = S(1.0f,0.9f,fract1f(dir.x*2.0f)* 3.333f -0.5f)-0.5f;

      float   on       = S(-1.0f,1.0f,sun);
      float   light    = (-1.0f + tilt * floor(on*10.0f) > 0.0f ? blink : -1.0f);
              light    = empty == 1.0f ? -0.5f : light;
      float   lum      = light > 0.0f ? -0.1f : 0.3f;

              col     -= tilt > 0.0f ? lum * wbevelR : 0.0f;
              col     += tilt > 0.0f ? light * winnerR : 0.0f;

              lights  += tilt > 0.0f ? light * winnerR : 0.0f;
              blights += tilt > 0.8f && flip == 1.0f ? light * bwinnerR : 0.0f;

      float t1 = stripes(pat - to_float2(0.01f,0.0f), prod_mat2_mat2(M(0.0f),M(0.02f)), 8.0f, 0.05f, blr*2.0f );
      float tt = stripes(pat - to_float2(fract_float2( prod_mat2_float2(M(-PI*0.666f),pat)*8.0f).x >0.5f ? 0.20f : 0.01f,0.00f), prod_mat2_mat2(M(0.0f),M(0.02f)), 8.0f, 0.05f, blr*2.0f );

//    float tt = stripes(pat - to_float2(((fract_float2(prod_mat2_float2(M(-PI*0.666f),pat)*8.0f)).x >0.5f ? 0.20f : 0.01f),0.00f),prod_mat2_mat2(M(0.0f),M(0.02f)), 8.0f, 0.05f, blr*2.0f );



      float t2 = stripes(pat - to_float2(-0.19f,0.01f), prod_mat2_mat2(M(TWO_PI*0.333f),M(0.02f)),   16.0f  , 0.05f, blr*2.0f );
      col += hills == 0.0f ? 0.1f*(t2+tt)* pow(noise((uv-motion*0.15f)*20.0f),1.5f) : 0.0f;

    } else
    {
      col = mix(col, to_float3(0.52f,0.13f,0.01f), 0.5f);
      col = mix(col, to_float3(0.5f,0.45f,0.1f), 1.0f-S(0.1f,0.3f,length1f(h.y - fb.y)));
    }
  }

  //  face 02 (left)
  //  ---------------
  if(pol.x >= ang.y)
  {
            col     += tilt > 0.2 ? to_float3_s(0.0f) : 0.3f * paint ;
    float2  dir      =  _cosf(T + h.z) > 0.0f ? prod_mat2_float2(M(PI),h.xy) : -prod_mat2_float2(M(PI),h.xy); // -M(PI)*h.xy
    float   blink    = S(1.0f,0.9f,fract1f(dir.x*2.0f)* 3.333f -0.5f)-0.5f;
    float   on       = S(-1.0f,1.0f,sun);
    float   light    = 0.5f*(-1.0f + tilt * floor(on*10.0f) > 0.0f ? blink : -1.0f);
            col      = hills == 1.0f ? mix(col,to_float3(0.52f,0.13f,0.01f), 0.5f) : col;
            col      = hills == 1.0f ? mix(col, to_float3(0.5f,0.45f,0.1f), 1.0f-S(0.1f,0.3f,length1f(h.y - fa.y))) : col;
            col     += tilt > 0.8f && flip == 1.0f ? light * winnerL : 0.0f;
            col     += tilt > 0.8f && flip == 1.0f ? light*0.3f * wbevelL : 0.0f;
            lights  += tilt > 0.8f && flip == 1.0f? light * winnerL : 0.0f;
            blights += tilt > 0.8f && flip == 1.0f? light * bwinnerL : 0.0f;

    // walls texture
    float t1 = stripes(pat - to_float2(0.01f,0.0f), prod_mat2_mat2(M(0.0f),M(0.02f)), 8.0f, 0.05f, blr*2.0f );
    float tt = stripes(pat - to_float2(fract_float2(prod_mat2_float2(M(-PI*0.333f),pat)*8.0f).x >0.5f ? 0.20f : 0.01f,0.00f), prod_mat2_mat2(M(0.0f),M(0.02f)), 8.0f, 0.05f, blr*2.0f );
    float t2 = stripes(pat - to_float2(-0.19f,0.01f), prod_mat2_mat2(M(TWO_PI*0.666f),M(0.02f)),   16.0f  , 0.05f, blr*2.0f );
    col += hills == 0.0f ? 0.15f*(t2+tt)* pow(noise((uv-motion*0.15f)*20.0f),1.5f) : 0.0f;

    // doors
    float2  pos1    = to_float2(0.25f,0.0f);
    float2  pos2    = to_float2(0.215f,0.0f);
    float   door    = stripes(pat + pos1 , prod_mat2_mat2(M(0.0f),M(0.02f)), 1.0f, 0.05f, blr);
    float   doorcut = 1.-stripes(pat + pos1 , prod_mat2_mat2(M(TWO_PI*0.666f),M(0.02f)), 1.0f, 0.18f, blr);
    float   maskcut = 1.-stripes(pat + pos2 , prod_mat2_mat2(M(TWO_PI*0.666f),M(0.02f)), 1.0f, 0.18f, blr);
    float   doormask= stripes(pat + pos2 , prod_mat2_mat2(M(0.0f),M(0.02f)), 1.0f, 0.05f, blr);
            door    =  min(door,doorcut);
            doormask= min(doormask, maskcut);
    float   dbevel  = SAT(min(door,door-doormask));

    col += doors == 1.0f && flip == 0.0f && hills == 0.0f ? dbevel * 0.2f : 0.0f;
    col += doors == 1.0f && flip == 0.0f && hills == 0.0f ? doormask * 0.4f : 0.0f;
  }


  //  face 03 (top)
  //  -------------
  if (pol.x > ang.x && pol.x < ang.y)
  {
    if (hills == 1.0f)
    {
      col += 0.1f * to_float3(0.5f,0.45f,0.1f);
      float grass = 1.0f-S(1.1f+blr, 0.5f-blr, dfDiamond(h.xy - to_float2(0.0f, 0.3f)));
      col = mix(to_float3(0.5f,0.45f,0.1f),col,1.0f-grass);
    }
  }

  //  face 04 (inside)
  //  ----------------
  //float2 ang2 = ang + to_float2(-0.1665f,0.1665f);
  //if (pol.x  <= ang2.x  || pol.x >= ang2.y)
  //{
  //}

  //  trees
  //  -----

  if ( tree == 1.0f)
  {
    float tw = 0.07f;
    float crown = S(0.25f+blr,0.25f,eDist2);

    float trunk = S(tw+blr, tw, hex(h.xy - to_float2(0.0f, 0.0f)));
    trunk = max(trunk,S(tw+(blr*0.5f), tw, hex(h.xy - to_float2(0.0f, 0.5f*tw*2.5f))));
    trunk = max(trunk,S(tw+(blr*0.5f), tw, hex(h.xy - to_float2(0.0f, 0.5f*tw*5.0f))));
    trunk = max(trunk,S(tw+(blr*0.5f), tw, hex(h.xy - to_float2(0.0f, 0.5f*tw*7.5f))));

    float a = pol.x < 0.5f ? 2.5f : 0.5f ;
    col = mix(col,to_float3(0.5f,0.3f,0.2f),trunk*a);
    col = mix(col,to_float3(0.55f,0.6f,0.3f),crown);

    float shw = 0.2f * S(0.5f + (blr*3.0f), 0.5f - blr, dfDiamond(fb + (to_float2(0.22f, 0.02f))));
    shw += 0.35f * S(0.5f + (blr*3.0f), 0.5f - blr, dfDiamond(fa - (to_float2(0.22f, -0.02f))));

    col -= shw;
  }

  if(hills == 1.0f)
  {
    col -= fao*0.2f;
  }


  //  Roof top
  //  --------

  float2 frh = fract_float2(h.xy * 2.0f);
  float d1 = S(0.8f+blr, 0.8f-blr, dfDiamond(h.xy - to_float2(0.0f, flip*0.3f)));
  float d2 = S(0.8f+blr, 0.8f-blr, dfDiamond(h.xy - to_float2(0.0f, flip*0.2f)));

  if (hills == 1.0f)
  {
    col  += 0.08f*(0.6f-hash2(uv*34869.54334f));
  }

  if(hills == 0.0f && flip == 1.0f)
  {
    if (empty == 0.0f)
    {
      float shw = pol.x < 0.5f ? 0.33f : 0.15f ;
      col -= shw *(d1-min(d1,min(d1,d2))); // inner bevel
      if( tilt > 0.7f)
      {
        float2 wtp = to_float2(0.0f,-0.2f);
        float2 wtp2 = to_float2(0.0f,-0.58f);
        float2 wtp3 = to_float2(0.0f,-0.25f);
        float watertank = S(0.02f,0.02f-(blr*0.5f),dot(h.xy*s + wtp, h.xy*s + wtp));
        float watertanktop = S(0.02f,0.02f-(blr*0.5f),dot(h.xy*s + wtp2, h.xy*s + wtp2));
        float watertanktop2 = S(0.016f,0.016f-(blr*0.5f),dot(h.xy*s + wtp2, h.xy*s + wtp2));
        float watertankside = 1.0f - rect(h.xy, wtp3, 0.1f,0.125f, blr);
        watertank = max(watertank,watertanktop);
        watertank = min(d1,watertank);
        watertankside = SAT(watertankside);
        float wtglobal = max(watertank, min(d1,watertankside));

        col = mix(col,to_float3(0.2f,0.32f,0.45f),wtglobal);
        col -= watertanktop2 * 0.15f;
        col += max(watertank,watertankside) * S(0.0f,0.15f,length1f(h.x-0.05f))*0.15f;
      } else
      {
        if(tilt > 0.3f )
        {
          float2 fanpos = to_float2(-0.1f,-0.35f);
          float fan = S(0.125f,0.125f-blr,hex(h.xy + fanpos));
          col = mix(col,to_float3_s(1.0f),fan);
          col = mix(col,0.95f*to_float3(0.9f,0.75f,0.6f),fan);
          float ff1 = dfDiamond(fa.xy + to_float2(0.35f,0.015f));
          float ff2 = dfDiamond(fb.xy - to_float2(0.255f,-0.19f));
          col -= to_float3_s(0.45f*S(0.26f,0.26f-(blr*2.0f),ff1));
          col -= to_float3_s(0.2f*S(0.26f,0.26f-(blr*2.0f),ff2));
        }
      }

    } else
    {
      float shw = pol.x < 0.5f ? 0.4f : 0.15f ;
      col -=  shw * d1; // empty houses
    }
  }

  // postprocessing

          col   /= 1.1f-0.2f;
          col   += mix(0.15f * S(0.0f,6.0f,length_float2(uv*s)), -0.8f * S(0.0f,6.0f,length_float2(uv*s)), sun);
          col    = clamp(col,to_float3_s(0.15f), to_float3_s(1.0f));

  float3  day    = col;
  float3  night  = col;
          night  = mix(day, to_float3(0.2f,0.5f,0.9f),0.5f);

          night  = pow(night, to_float3_s(3.0f));
          night += SAT(lights);
          night += SAT(blights)*4.0f ;

  float3  final = mix(day,night,S(-1.0f, 1.0f,sun));


  // color output
  fragColor = to_float4_aw(final,1.0f);

  //##########################################################################


  //fragColor = to_float4(1.0f,1.0f,0.0f,0.0f); // WECH!
  _tex2DVec4Write(dst, x, y, fragColor);

}

]]

-- "LUA CODE..." /**

-- // ------------------------------------------------------------------------
-- // Create
-- // ------------------------------------------------------------------------

function Create()

  ----- In/Out
  InImage1 = self:AddInput("Image", "Image", {
    LINKID_DataType = "Image",
    LINK_Main = 1,
    INP_Required = false
  })

  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main = 1,
  })

  ----- Inspector Panel Controls

   InFreq = self:AddInput("Frequency", "Frequency", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 2.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
  })

  InSIZE = self:AddInput("SIZE", "SIZE", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 0.4,
    INP_MinScale 	     = 0.1,
    INP_MaxScale 	     = 1.5,
  })

  InSunshine = self:AddInput("Sunshine", "Sunshine", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 0.3,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 2.0, -- 2*Pi
  })

  InSuntime = self:AddInput("Suntime", "Suntime", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "CheckboxControl",
	  INP_Integer         = true,
    INP_Default         = 1,
--    IC_Visible          = true,
  })


  ------ Information

  InfoButton = self:AddInput("Info ...", "InfoButton", {
    LINKID_DataType = "Text",
    INPID_InputControl = "ButtonControl",
    INP_DoNotifyChanged = true,
    INP_External = false,
    IC_ControlPage = -1,
  })

  InShaderInfoBlock = self:AddInput([[<hr />Shadertoy <a href="https://www.shadertoy.com/view/]]..shadertoy_id..[[" style="color:white; text-decoration:none; ">]]..shadertoy_name
      ..[[</a> by <a href="https://www.shadertoy.com/user/]]..shadertoy_author..[[" style="color:yellow; text-decoration:none; ">]]..shadertoy_author..[[</a><br />]]
      ..shadertoy_license.. ( shadertoy_license=="" and "" or "<br>" )..[[DCTLified and DaFused by <a href="]]..dctlfuse_authorurl..[[" style="color:white; text-decoration:none; ">]]
      ..dctlfuse_author..[[</a>]]..(dctlfuse_versionDate=="" and " v0."..dctlfuse_versionNo or "<br />Version 0."..dctlfuse_versionNo.." - "..dctlfuse_versionDate),"Label", {
    LINKID_DataType = "Text", INPID_InputControl = "LabelControl", LBLC_MultiLine = true, IC_NoLabel = true, IC_NoReset = true, INP_External = false, INP_Passive = true, -- IC_ControlPage = -1,
  })

  if true then
    InNmbr73Logo = self:AddInput(
        "<p align=\"right\"><a href=\"https://www.youtube.com/c/nmbr73\"><img width=\"212\" height=\"41\" src=\"data:image/png;base64,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\" /></a></p>",
        "Nmbr73Logo", {
        LINKID_DataType = "Text",
        INPID_InputControl = "LabelControl",
        LBLC_MultiLine = true,
        IC_NoLabel = true,
        IC_NoReset = true,
        INP_External = false,
        INP_Passive = true,
        -- IC_ControlPage = -1,
        })
    end
  end


-- // ------------------------------------------------------------------------
-- // Process
-- // ------------------------------------------------------------------------

function Process(req)

    local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate") -- get the frame rate of the comp set in the preferences

    --This creates an image for us to work on.
    local imgattrs = {
        IMG_Document = self.Comp,
        { IMG_Channel = "Red", },
        { IMG_Channel = "Green", },
        { IMG_Channel = "Blue", },
        { IMG_Channel = "Alpha", },
        IMG_Width = Width,
        IMG_Height = Height,
        IMG_XScale = XAspect,
        IMG_YScale = YAspect,
        IMAT_OriginalWidth = realwidth,
        IMAT_OriginalHeight = realheight,
        IMG_Quality = not req:IsQuick(),
        IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
        }

    if not req:IsStampOnly() then
        imgattrs.IMG_ProxyScale = 1
    end

    if SourceDepth ~= 0 then
        imgattrs.IMG_Depth = SourceDepth
    end


    -- Extern Texture or create a new one
    if (InImage1:GetValue(req) ~= nil) then
        src1 = InImage1:GetValue(req)
    else
        src1 = Image(imgattrs)
        local p = Pixel({R=0,G=0,B=0,A=0}) -- Initial black Image to avoid see random picture from Memory
        src1:Fill(p)
    end

    local dst = Image {IMG_Like = src1, IMG_DeferAlloc = true} -- create an Output Image


    -- Interface for running DCTL-Code

    node = DVIPComputeNode(req, "ST_FavelaKernel", GLSL_CompabilityCode..ST_FavelaKernel, "ST_FavelaParams", ST_FavelaParams)


    if not pcall(function ()  -- necessary to avoid memory leakage
        params.freq         = InFreq:GetValue(req).Value
        params.SIZE         = InSIZE:GetValue(req).Value
        params.Sunshine     = InSunshine:GetValue(req).Value
        params.Suntime      = InSuntime:GetValue(req).Value
        params.compOrder    = src1:IsMask() and 1 or 15
        params.width        = src1.DataWindow:Width()
        params.height       = src1.DataWindow:Height()
        params.iTime        = req.Time / framerate
        node:SetParamBlock(params)
    end) then
        params              = node:GetParamBlock(ST_FavelaParams)
        params.freq         = InFreq:GetValue(req).Value
        params.SIZE         = InSIZE:GetValue(req).Value
        params.Sunshine     = InSunshine:GetValue(req).Value
        params.Suntime      = InSuntime:GetValue(req).Value
        params.compOrder    = src1:IsMask() and 1 or 15
        params.width        = src1.DataWindow:Width()
        params.height       = src1.DataWindow:Height()
        params.iTime        = req.Time / framerate
        node:SetParamBlock(params)
    end


    node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)

    node:AddInput("iChannel0", src1)
    node:AddOutput("dst",      dst)

    local success = node:RunSession(req)
    if not success then
        dst = nil
        dump(node:GetErrorLog()) -- Errormessages from DCTL-Compiler
    end
    OutImage:Set(req, dst)
end



-- // ------------------------------------------------------------------------
-- // Callback
-- // ------------------------------------------------------------------------

function NotifyChanged(inp, param, time)
	if (param ~= nil) then
		if (param.Value == 1) then
			if (inp == InfoButton) then
				bmd.openurl(dctlfuse_infourl)
			end
		end
	end
end


-- **/ "End of LUA CODE"
