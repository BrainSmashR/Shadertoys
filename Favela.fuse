--[[--/*

    Favela.fuse

    Based on https://www.shadertoy.com/view/ldGcDh a WebGL
    shader from shadertoy.com converted to DCTL and embeddet
    into a Lua Fuse by nmbr73 (https://www.youtube.com/c/nmbr73)
    for use in DaFusion.
    
    Shader created by duvengar

    Favela by Julien Vergnaud @duvengar-2018
    License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.
    Based on the Minimal Hexagonal Grid example from @Shane.
    Minimal Hexagonal Grid - Shane
    https://www.shadertoy.com/view/Xljczw



    === STATUS ===

    runs      on macOS / Metal
    CRASHES!  on macOS / OpenCL

    ... and it has some incosistencies (grass on the walls and such)

*/--]]--



local shadertoy_name       = "Favela"
local shadertoy_author     = "duvengar"
local shadertoy_id         = "ldGcDh"
local shadertoy_license    = "Favela by Julien Vergnaud @duvengar-2018 (CC-BY-SA)"
local dctlfuse_code        = true 
local dctlfuse_name        = "Favela"
local dctlfuse_author      = "nmbr73"
local dctlfuse_authorurl   = "https://www.youtube.com/c/nmbr73"
local dctlfuse_infourl     = "https://nmbr73.github.io/Shadertoys/"
local dctlfuse_versionNo   = 1
local dctlfuse_versionDate = ""





-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------

FuRegisterClass("ST_"..dctlfuse_name, CT_SourceTool, {
  REGS_Category          = "Fuses\\Shadertoys",
  REGS_OpIconString      = "ST-"..shadertoy_id,
  REGS_OpDescription     = "Shadertoy '"..shadertoy_name.."' (ID: "..shadertoy_id..")",

  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,

  REG_Source_GlobalCtrls = false,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  REG_OpNoMask           = true,
  REG_Fuse_NoEdit        = not(dctlfuse_code),
  REG_Fuse_NoReload      = not(dctlfuse_code),

  REG_TimeVariant        = true,

  REGS_Company           = dctlfuse_author,
  REGS_URL               = dctlfuse_authorurl,
  REG_Version            = dctlfuse_versionNo,
  })



-- // ------------------------------------------------------------------------
-- // DCTL kernel parameters
-- // ------------------------------------------------------------------------
 
FavelaParams =
[[
  float freq;
  int   width;
  int   height;
  float iTime;
  int   compOrder;
]]



-- // ------------------------------------------------------------------------
-- DCTL kernel implementation 
-- // ------------------------------------------------------------------------

FavelaKernel =
    [[


///////////////////////////////////////////////////////////////////////////////////////////////////
// Helper funnctions for compability:
///////////////////////////////////////////////////////////////////////////////////////////////////

// @tida : did you fin out if you need to build a function for length?!?
// See https://www.steakunderwater.com/wesuckless/viewtopic.php?p=35549&sid=c4b440f6caff5fb5e24d0318a0a36bdb#p35549
// However, I need length and don't know if there is a differently named implementation in DCTL:

__DEVICE__ inline float length1f(float f)
{
  return f; 
} 

__DEVICE__ inline float length2f(float2 v) 
{ 
  return _sqrtf(v.x*v.x+v.y*v.y);
} 


// Don't know if a to_float4(float2,float2) exists?!?

__DEVICE__ inline float4 to_float4_22(float2 a, float2 b)
{ 
  //float4 t(a.x,a.y,b.x,b.y); 
  return float4(a.x,a.y,b.x,b.y); 
}


// In Cuda the fract function is missing

#if DEVICE_IS_CUDA
  __DEVICE__ float fract1f(float f){return f - _floor(f);} 
#endif


// Our 2x2 matrix

typedef struct
{
  float2 r0;
  float2 r1;
} mat2;

__DEVICE__ inline mat2 to_mat2( float2 a, float2 b)
{
  mat2 t;
  t.r0 = a; 
  t.r1 = b; 
  return t; 
} 

__DEVICE__ inline mat2 to_mat2( float a, float b, float c, float d)
{
  mat2 t;
  t.r0.x = a; 
  t.r0.y = b; 
  t.r1.x = c; 
  t.r1.y = d; 
  return t; 
} 

__DEVICE__ inline mat2 mat2_MULT_mat2( mat2 a, mat2 b)  
{  
  mat2 t;  
  t.r0.x = a.r0.x * b.r0.x + a.r0.y * b.r1.x;   t.r0.y = a.r0.x * b.r0.y + a.r0.y * b.r1.y;
  t.r1.x = a.r1.x * b.r0.x + a.r1.y * b.r1.x;   t.r1.y = a.r1.x * b.r0.y + a.r1.y * b.r1.y;
  return t;  
}

__DEVICE__ inline float2 float2_MULT_mat2( float2 v, mat2 m )  
{  
  //float2 t;  
  //t.x = v.x * m.r0.x + v.y * m.r1.x;  
  //t.y = v.x * m.r0.y + v.y * m.r1.y;  
 // return float2(v.x*m.r0.x + v.y*m.r1.x, v.x*m.r0.y + v.y*m.r1.y);  


  return float2(v.x*m.r0.x + v.y*m.r0.y, v.x*m.r1.x + v.y*m.r1.y);  
}

__DEVICE__ inline float2 mat2_MULT_float2( mat2 m, float2 v )  
{  
  return float2(v.x*m.r0.x + v.y*m.r1.x, v.x*m.r0.y + v.y*m.r1.y);  
//  return float2(v.x*m.r0.x + v.y*m.r0.y, v.x*m.r1.x + v.y*m.r1.y);  
}


__DEVICE__ inline mat2 mat2_MULT_float( mat2 m, float s)  
{ 
  mat2 t;
  t.r0.x = s * m.r0.x; 
  t.r0.y = s * m.r0.y; 
  t.r1.x = s * m.r1.x; 
  t.r1.y = s * m.r1.y; 
  return t;
}

__DEVICE__ inline mat2 float_MULT_mat2( float s, mat2 m) { return mat2_MULT_float(m,s); }  



///////////////////////////////////////////////////////////////////////////////////////////////////


// hash2 taken from Dave Hoskins https://www.shadertoy.com/view/4djSRW
__DEVICE__ float hash2(float2 p)
{
  float3 p3  = fract(p.xyx * 0.2831f);
  p3 += dot(p3, p3.yzx + 19.19f);
  return fract((p3.x + p3.y) * p3.z);
}


///// NOISE /////
__DEVICE__ float hash(float n)
{
  return fract(_sinf(n)*43758.5453123f);
}


__DEVICE__ float noise(float2 x)
{
  float2 p = floor(x);
  float2 f = fract(x);
  f = f * f * (3.0f - 2.0f * f);
  float n = p.x + p.y * 57.0f;
  return mix(mix(hash(n + 0.0f), hash(n + 1.0f), f.x), mix(hash(n + 57.0f), hash(n + 58.0f), f.x), f.y);
}


////// FBM ////// 
// see iq // https://www.shadertoy.com/view/lsfGRr

__DEVICE__ float fbm(float2 p)
{ 
  const mat2 m = to_mat2( 0.6f, 0.6f, -0.6f, 0.8f);

  float f = 0.0f;
  f += 0.5000f * noise(p); p = float2_MULT_mat2(p,mat2_MULT_float(m, 2.02f));
  f += 0.2500f * noise(p); p = float2_MULT_mat2(p,mat2_MULT_float(m, 2.03f));
  f += 0.1250f * noise(p); p = float2_MULT_mat2(p,mat2_MULT_float(m, 2.01f));
  f += 0.0625f * noise(p); p = float2_MULT_mat2(p,mat2_MULT_float(m, 2.04f));
  f /= 0.9375f;
  return f;
}

/*
__DEVICE__ float4 someFunction( float4 a, float b )
{
    return a+b;
}


// iq's cosine palette function
__DEVICE__ float3 palette( float t, float3 a, float3 b, float3 c, float3 d )
{
    return a + b*_cosf( 6.28318f*(c*t+d) );
}

*/
///////////////////////////////////////////////////////////////////////////////////////////////////

#ifdef DEVICE_IS_METAL  

  constant float2 s = to_float2(1.0f, 1.7320508f);
  constant float LOWRES = 50.0f;

#else

  const float2 s = to_float2(1.0f, 1.7320508f);
  const float LOWRES = 50.0f;

#endif



__DEVICE__ float hex(float2 p)
{
  p = _fabs(p);
  return _fmaxf(dot(p, s *0.5f), p.x );
}


__DEVICE__ float4 getHex(float2 p)
{  
 
  float4 hC = floor(to_float4_22(p, p - to_float2(0.5f, 1.0f)) / s.xyxy) + 0.5f;
  float4 h = to_float4_22(p - hC.xy*s, p - (hC.zw + 0.5f)*s);
  return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? to_float4_22(h.xy, hC.xy) : to_float4_22(h.zw, hC.zw + to_float2(0.5f, 1.0f)); 
}

/////////////////////////////////////////////////////////////////////////////////////////////////////


#define M(a) to_mat2(_cosf(a), -_sinf(a), _sinf(a), _cosf(a))
#define S(a, b, c) smoothstep(a, b, c)
#define SAT(a) _clampf(a, 0.0f, 1.0f)
#define T iTime
#define PI _acosf(-1.0f)
#define TWO_PI (PI * 2.0f)
#define SIZE 0.4f
#define BLUR 0.02f


__DEVICE__ float rem(float2 iR)
{
    float slices = 10.0f * floor(iR.y / LOWRES);  
    return  _sqrtf(slices);
}


__DEVICE__ float stripes( float2 uv, mat2 rot, float num, float amp, float blr)
{   
    uv = float2_MULT_mat2(uv,rot); // was: uv *= rot;
    // uv *= M(.02);
    float h =  smoothstep(amp+blr, amp - blr,  length1f(fract(uv.x * num )-0.5f));
    return h;
}


__DEVICE__ float dfDiamond(float2 h)
{
    h *= s; // rescale diamond verticaly with the helper vector
    float2 p =  to_float2(_fabs(h.x), _fabs(h.y));
    float d = (p.x+p.y)/0.5f; 
    //return S(.2,.9,length(d));
    return d;
}

__DEVICE__ float rect(float2 uv,float2 p, float w, float h, float b)
{    
    uv += p;
    float rv = S(h, h + b, length1f(uv.x));
    float rh = S(w, w + b, length1f(uv.y));
    return rv + rh;
}



//############################################################################


__KERNEL__ void FavelaKernel(
    __CONSTANTREF__ FavelaParams*  params, 
    __TEXTURE2D__                  iChannel0, 
    __TEXTURE2D_WRITE__            dst
    )
{

  DEFINE_KERNEL_ITERATORS_XY(x, y);
      
  if (x >= params->width || y >= params->height)
  return;

  // ----- Standard parameters
  float2 fragCoord   = to_float2(x, y); 
  float2 iResolution = to_float2(params->width, params->height);
  float  iTime       = params->iTime * params->freq;
  float4 fragColor   = to_float4_s(0.0f);

  //##########################################################################

  //  set up pixel coord
  //  ------------------
  float2 uv = (2.0f * fragCoord - iResolution.xy) / iResolution.y;     // [nmbr73] or just iResolution without .xy?
  uv = float2_MULT_mat2(uv,M(0.25f * _cosf(PI) * 0.5f * length2f(uv)));  // twist the pixels domain
  uv *= 1.1f;                                                          // scale up the pixels domain
  uv = float2_MULT_mat2(uv,M(PI));                                     // rotate the pixels domain
  uv *= 0.8f+dot(uv*0.3f,uv*0.3f);                                     // length distortion


  //  ------------------------------------------------------------------------------------------------
  //  variables
  //  ------------------------------------------------------------------------------------------------
  float   motion  = 325.543f + T * 0.5f;		          // speed
  float   SCALE   = rem(iResolution.xy)*SIZE;         // screen rescaling ratio

  // three options for the initialisation of the blur value were given
  // in the original shadertoy. But the one actually used there does not
  // work in DCTL without further changes to substitute fwidth() ...
  //float   blr     = BLUR;				                    
  //float   blr     = fwidth(uv.x)*length(uv)*8.0f;   // blur value
  float   blr     = S(0.0f,1.0f,length2f(uv)*0.13f); 
  float2  pos     = uv - motion;                      // position
  float3  lights  = to_float3_s(0.0f);
  float3  blights = to_float3_s(0.0f);
  float   sun     = _cosf(T*0.3f);

  //  Hexagons grid
  //  -------------
  
  float4  h       = getHex( pos + SCALE * uv + s.yx); // hexagons center
  float   eDist   = hex(h.xy);                   // hexagone Edge distance.   
	float   eDist2  = hex(h.xy + to_float2(0.0f,0.25f));
  float   cDist   = length(h.xy);                // @Shane: cDist = dot(h.xy, h.xy);  
    
  float   tilt    = hash2(h.zw*2376.345791f);     // random value depending on cel ids
  

  //  ------------------------------------------------------------------------------------------------    
  //  sorting the hexagons
  //  ------------------------------------------------------------------------------------------------

  //  hexagons states booleans
  //  ------------------------
  float hills = 0.0f;
  float red   = 0.0f;
  float flip  = 0.0f;
  float empty = 0.0f;
  float tex   = 0.0f;
  float wnds  = 0.0f;
  float tree  = 0.0f;
  float doors = 0.0f;

  //  wich tile are flipped?
  //  ----------------------
  float ff = _cosf(5.0f * _sinf(h.z - h.w)*tilt);
  if (ff > 0.0f)
  {
    flip = 1.0f;
    h.xy = float2_MULT_mat2(h.xy,M(PI)); // does swizzling work on all platforms

    empty = ff > 0.99f ? 1.0f : 0.0f;
  } 
        
        
  //  polar coordinates + cubes faces angles
  //  --------------------------------------
  float2 pol = to_float2(_atan2f(h.x, h.y) / TWO_PI + 0.5f, length2f(uv));
  float2 ang = to_float2(0.333333f, 0.666666f);

  if (pol.x <=  ang.x || tilt >= 0.7f)
  { 
    wnds = 1.0f;

    if(tilt >=0.9f)
      doors = 1.0f;
  }

  //  wich tiles are hills?
  //  ---------------------
  if (flip == 0.0f && noise(h.zw)*0.5f > 0.3f)
  {
    hills = 1.0f;
    tree = tilt > 0.5f ? 1.0f : 0.0f;
  }

  //  ------------------------------------------------------------------------------------------------    
  //  create the windows elements 
  //  ------------------------------------------------------------------------------------------------    
    
  float2 pat  = h.xy;                                                                             // original position (up lozenge in the hexagon)
  float2 pat2 = h.xy-(to_float2(flip == 1.0f ? 0.05f : -0.05, flip == 1.0f ? 0.03f : - 0.03f));   // offseted and rotated position on the right side
  float2 pat3 = h.xy-(to_float2(flip == 0.0f ? 0.05f : -0.05, flip == 1.0f ? 0.05f : - 0.05f));   // offseted and rotated position on the left side

    
  float s1  = stripes(pat,  mat2_MULT_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 2.0f: 4.0f, 0.3f, blr );  // vertical stripes
  float s2  = stripes(pat,  mat2_MULT_mat2(M(TWO_PI*0.666f),  M(0.02f)), 4.0f, 0.3f, blr );                       // oriented stripes

  float s3  = stripes(pat,  mat2_MULT_mat2(M(TWO_PI*0.333f),  M(0.02f)), 4.0f, 0.3f, blr );
  float s4  = stripes(pat,  mat2_MULT_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 4.0f: 2.0f, 0.3f, blr );

  float m1  = stripes(pat2, mat2_MULT_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 2.0f: 4.0f, 0.3f, blr );
  float m2  = stripes(pat2, mat2_MULT_mat2(M(TWO_PI*0.333f ), M(0.02f)), 4.0f, 0.3f, blr );

  float ml1 = stripes(pat3, mat2_MULT_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 4.0f: 4.0f, 0.3, blr );
  float ml2 = stripes(pat3, mat2_MULT_mat2(M(TWO_PI*0.666f),  M(0.02f)), 4.0f, 0.3f, blr );

  float windowsR  = min(s1,s3);                     // windows on the Right side
  float windowsL  = min(s4,s2);                     // windows on the Left side

  float maskR     = min(m1,m2);                     // offseted Right windows
  float maskL     = min(ml1,ml2);                   // offseted Left windows

  float winnerR   = min(windowsR, maskR);           // cuted Right inner windows
  float winnerL   = min(windowsL, maskL);           // cuted Left inner windows

  float wbevelR   = min(windowsR,windowsR-winnerR); // cuted Right bevel
  float wbevelL   = min(windowsL,windowsL-winnerL); // cuted Left bevels

    
  //  blured windows
  //  --------------
    
  float blr2  = BLUR * 8.;

  float bs1   = stripes(pat,  mat2_MULT_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 2.0f: 4.0f, 0.3f, blr2 );   // vertical stripes
  float bs2   = stripes(pat,  mat2_MULT_mat2(M(TWO_PI*0.666f),  M(0.02f)), 4.0f, 0.3f, blr2 );                        // oriented stripes

  float bs3   = stripes(pat,  mat2_MULT_mat2(M(TWO_PI*0.333f ), M(0.02f)), 4.0f, 0.3f, blr2 );
  float bs4   = stripes(pat,  mat2_MULT_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 4.0f: 2.0f, 0.3f, blr2 );

  float bm1   = stripes(pat2, mat2_MULT_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 2.0f: 4.0f, 0.3f, blr2 );
  float bm2   = stripes(pat2, mat2_MULT_mat2(M(TWO_PI*0.333f ), M(0.02f)), 4.0f, 0.3f, blr2 );

  float bml1  = stripes(pat3, mat2_MULT_mat2(M(0.0f),           M(0.02f)), flip == 1.0f ? 4.0f: 4.0f, 0.3f, blr2 );
  float bml2  = stripes(pat3, mat2_MULT_mat2(M(TWO_PI*0.666f),  M(0.02f)), 4.0f, 0.3f, blr2 );

  float bwindowsR = min(bs1,bs3);             // windows on the Right side
  float bwindowsL = min(bs4,bs2);             // windows on the Left side

  float bmaskR    = min(bm1,bm2);             // offseted Right windows
  float bmaskL    = min(bml1,bml2);           // offseted Left windows

  float bwinnerR  = min(bwindowsR, bmaskR);   // cuted Right inner windows
  float bwinnerL  = min(bwindowsL, bmaskL);   // cuted Left inner windows
       
  //  ------------------------------------------------------------------------------------------------      
  //  shading the cubes faces
  //  ------------------------------------------------------------------------------------------------    

  //  noise texture
  //  -------------
  float3 col = to_float3_s(1.0f);
  float n1 = 0.5f-(fbm(((uv -motion*0.24f)* 20.0f)));
  float n2 = 0.5f-(fbm(((uv -motion*0.31f)* 5.0f)));
  col += 0.4f * (max(n1,n2));

  
  //  painting
  //  --------
  float3 paint = to_float3(_cosf(h.z + h.w *0.2f),_cosf(tilt)*0.3f,noise(h.zw));
     
  //  lightning
  //  ---------
  float2 facespos = h.xy;
  facespos = float2_MULT_mat2(facespos, M(TWO_PI*ang.x));

  float2 fa = facespos;
  float shw = 0.7f * S(1.1f+ blr, 1.0f-blr, dfDiamond(facespos - (to_float2(0.0f, 0.3f))));
  facespos = float2_MULT_mat2(facespos,M(TWO_PI*ang.x));

  float2 fb = facespos;
  shw += 0.2f * S(1.1f+blr, 1.0f-blr, dfDiamond(facespos - (to_float2(0.0f, 0.3f))));
  col -= shw;


  float fao = _clampf(smoothstep(1.0f,0.0f,eDist), 0.0f, 1.0f);               // Fake lightning gradient 
  //fao = hills == 1. ? fao * 1.5 : fao;
  fao = flip == 0.0f || empty == 0.1f ?  0.65f * fao :  0.65f * (1.0f-fao);   // apply it as a shadow or light on the cubes
  col -= fao;
  col = mix(col,to_float3(0.7f,0.3f,0.0f),0.45f);


  //  face 01 (right)
  //  --------------   
  if(pol.x <=  ang.x )
  {    
    if ( hills == 0.0f)
    {
              col      = tilt > 0.2f  ? col :  col +0.3f * paint ;
      float2  dir      = cos(T + h.z) > 0.0f ? mat2_MULT_float2(M(PI/3.0f),h.xy) : -mat2_MULT_float2(M(PI/3.0f),h.xy); // was: -M(PI/3.0f)*h.xy;
      float   blink    = S(1.0f,0.9f,fract(dir.x*2.0f)* 3.333f -0.5f)-0.5f;
    
      float   on       = S(-1.0f,1.0f,sun);
      float   light    = (-1.0f + tilt * floor(on*10.0f) > 0.0f ? blink : -1.0f);
              light    = empty == 1.0f ? -0.5f : light;
      float   lum      = light > 0.0f ? -0.1f : 0.3f;
    
              col     -= tilt > 0.0f ? lum * wbevelR : 0.0f;
              col     += tilt > 0.0f ? light * winnerR : 0.0f;
                
              lights  += tilt > 0.0f ? light * winnerR : 0.0f;
              blights += tilt > 0.8f && flip == 1.0f ? light * bwinnerR : 0.0f;
        
      float t1 = stripes(pat - to_float2(0.01f,0.0f), mat2_MULT_mat2(M(0.0f),M(0.02f)), 8.0f, 0.05f, blr*2.0f );
      float tt = stripes(pat - to_float2(fract(mat2_MULT_float2(M(-PI*0.666f),pat)*8.0f).x >0.5f ? 0.20f : 0.01f,0.00f), mat2_MULT_mat2(M(0.0f),M(0.02f)), 8.0f, 0.05f, blr*2.0f );
      float t2 = stripes(pat - to_float2(-0.19f,0.01f), mat2_MULT_mat2(M(TWO_PI*0.333f),M(0.02f)),   16.0f  , 0.05f, blr*2.0f );
      col += hills == 0.0f ? 0.1f*(t2+tt)* pow(noise((uv-motion*0.15f)*20.0f),1.5f) : 0.0f;
                
    } else
    {
      col = mix(col, to_float3(0.52f,0.13f,0.01f), 0.5f);   
      col = mix(col, to_float3(0.5f,0.45f,0.1f), 1.0f-S(0.1f,0.3f,length1f(h.y - fb.y)));        
    }
  }

  //  face 02 (left)
  //  ---------------
  if(pol.x >= ang.y)     
  { 
    col += tilt > 0.2 ? to_float3_s(0.0f) : 0.3f * paint ;
    float2 dir =  _cosf(T + h.z) > 0.0f ? mat2_MULT_float2(M(PI),h.xy) : -mat2_MULT_float2(M(PI),h.xy); // -M(PI)*h.xy 
    float blink = S(1.0f,0.9f,fract(dir.x*2.0f)* 3.333f -0.5f)-0.5f;
    float on = S(-1.0f,1.0f,sun);
    float light = 0.5f*(-1.0f + tilt * floor(on*10.0f) > 0.0f ? blink : -1.0f);
    col = hills == 1.0f ? mix(col,to_float3(0.52f,0.13f,0.01f), 0.5f) : col;  
    col =  hills == 1.0f ? mix(col, to_float3(0.5f,0.45f,0.1f), 1.0f-S(0.1f,0.3f,length1f(h.y - fa.y))) : col;      
    col += tilt > 0.8f && flip == 1.0f ? light * winnerL : 0.0f;
    col += tilt > 0.8f && flip == 1.0f ? light*0.3f * wbevelL : 0.0f;
    lights += tilt > 0.8f && flip == 1.0f? light * winnerL : 0.0f;
    blights += tilt > 0.8f && flip == 1.0f? light * bwinnerL : 0.0f;
    //      walls texture
    float t1 = stripes(pat - to_float2(0.01f,0.0f), mat2_MULT_mat2(M(.0),M(.02)), 8.0f, 0.05f, blr*2.0f );
    float tt = stripes(pat - to_float2(fract(mat2_MULT_float2(M(-PI*0.333f),pat)*8.0f).x >0.5f ? 0.20f : 0.01f,0.00f), mat2_MULT_mat2(M(0.0f),M(0.02f)), 8.0f, 0.05f, blr*2.0f );
    float t2 = stripes(pat - to_float2(-.19,.01), mat2_MULT_mat2(M(TWO_PI*0.666f),M(0.02f)),   16.0f  , 0.05f, blr*2.0f );

    col += hills == 0.0f ? 0.15f*(t2+tt)* pow(noise((uv-motion*0.15f)*20.0f),1.5f) : 0.0f;
    //      doors        
    float2 pos1 = to_float2(0.25f,0.0f);
    float2 pos2 = to_float2(0.215f,0.0f);
    float door = stripes(pat + pos1 , mat2_MULT_mat2(M(0.0f),M(0.02f)), 1.0f, 0.05f, blr);
    float doorcut = 1.-stripes(pat + pos1 , mat2_MULT_mat2(M(TWO_PI*0.666f),M(0.02f)), 1.0f, 0.18f, blr);
    float maskcut = 1.-stripes(pat + pos2 , mat2_MULT_mat2(M(TWO_PI*0.666f),M(0.02f)), 1.0f, 0.18f, blr);
    float doormask = stripes(pat + pos2 , mat2_MULT_mat2(M(0.0f),M(0.02f)), 1.0f, 0.05f, blr);
    door =  min(door,doorcut);
    doormask = min(doormask, maskcut);
    float dbevel = SAT(min(door,door-doormask));
    col += doors == 1.0f && flip == 0.0f && hills == 0.0f ? dbevel * 0.2f : 0.0f;
    col += doors == 1.0f && flip == 0.0f && hills == 0.0f ? doormask * 0.4f : 0.0f;
  }

  
  //  face 03 (top)
  //  -------------
  if (pol.x > ang.x && pol.x < ang.y)
  { 
    if (hills == 1.0f)
    {
      col += 0.1f * to_float3(0.5f,0.45f,0.1f); 
      float grass = 1.0f-S(1.1f+blr, 0.5f-blr, dfDiamond(h.xy - to_float2(0.0f, 0.3f)));
      col = mix(to_float3(0.5f,0.45f,0.1f),col,1.0f-grass);     
    }
  }

  //  face 04 (inside)
  //  ----------------
  float2 ang2 = ang + to_float2(-0.1665f,0.1665f);
  if (pol.x  <= ang2.x  || pol.x >= ang2.y)
  { 
  }

  //  trees  
  //  -----
    
  if ( tree == 1.0f)
  {
    float tw = 0.07f;
    float crown = S(0.25f+blr,0.25f,eDist2);

    float trunk = S(tw+blr, tw, hex(h.xy - to_float2(0.0f, 0.0f)));
    trunk = max(trunk,S(tw+(blr*0.5f), tw, hex(h.xy - to_float2(0.0f, 0.5f*tw*2.5f))));
    trunk = max(trunk,S(tw+(blr*0.5f), tw, hex(h.xy - to_float2(0.0f, 0.5f*tw*5.0f))));
    trunk = max(trunk,S(tw+(blr*0.5f), tw, hex(h.xy - to_float2(0.0f, 0.5f*tw*7.5f))));

    float a = pol.x < 0.5f ? 2.5f : 0.5f ;
    col = mix(col,to_float3(0.5f,0.3f,0.2f),trunk*a);
    col = mix(col,to_float3(0.55f,0.6f,0.3f),crown);  

    float shw = 0.2f * S(0.5f + (blr*3.0f), 0.5f - blr, dfDiamond(fb + (to_float2(0.22f, 0.02f))));
    shw += 0.35f * S(0.5f + (blr*3.0f), 0.5f - blr, dfDiamond(fa - (to_float2(0.22f, -0.02f))));

    col -= shw;
  }

  if(hills == 1.0f)
  {
    col -= fao*0.2f;
  }    


  //  Roof top
  //  --------

  float2 frh = fract(h.xy * 2.0f);
  float d1 = S(0.8f+blr, 0.8f-blr, dfDiamond(h.xy - to_float2(0.0f, flip*0.3f)));
  float d2 = S(0.8f+blr, 0.8f-blr, dfDiamond(h.xy - to_float2(0.0f, flip*0.2f)));

  if (hills == 1.0f)
  {
    col  += 0.08f*(0.6f-hash2(uv*34869.54334f));      
  }

  if(hills == 0.0f && flip == 1.0f)
  {   
    if (empty == 0.0f)
    {            
      float shw = pol.x < 0.5f ? 0.33f : 0.15f ;
      col -= shw *(d1-min(d1,min(d1,d2))); // inner bevel
      if( tilt > 0.7f)
      {	
        float2 wtp = to_float2(0.0f,-0.2f);
        float2 wtp2 = to_float2(0.0f,-0.58f);
        float2 wtp3 = to_float2(0.0f,-0.25f);
        float watertank = S(0.02f,0.02f-(blr*0.5f),dot(h.xy*s + wtp, h.xy*s + wtp));
        float watertanktop = S(0.02f,0.02f-(blr*.5),dot(h.xy*s + wtp2, h.xy*s + wtp2));
        float watertanktop2 = S(0.016f,0.016f-(blr*0.5f),dot(h.xy*s + wtp2, h.xy*s + wtp2));
        float watertankside = 1.0f - rect(h.xy, wtp3, 0.1f,0.125f, blr);
        watertank = max(watertank,watertanktop);
        watertank = min(d1,watertank);
        watertankside = SAT(watertankside);
        float wtglobal = max(watertank, min(d1,watertankside));

        col = mix(col,to_float3(0.2f,0.32f,0.45f),wtglobal);
        col -= watertanktop2 * 0.15f;
        col += max(watertank,watertankside) * S(0.0f,0.15f,length1f(h.x-0.05f))*0.15f;
      } else 
      {
        if(tilt > 0.3f )
        {
          float2 fanpos = to_float2(-0.1f,-0.35f);
          float fan = S(0.125f,0.125f-blr,hex(h.xy + fanpos));
          col = mix(col,to_float3_s(1.0f),fan);
          col = mix(col,0.95f*to_float3(0.9f,0.75f,0.6f),fan);
          float ff1 = dfDiamond(fa.xy + to_float2(0.35f,0.015f));
          float ff2 = dfDiamond(fb.xy - to_float2(0.255f,-0.19f));
          col -= to_float3_s(0.45f*S(0.26f,0.26f-(blr*2.0f),ff1));
          col -= to_float3_s(0.2f*S(0.26f,0.26f-(blr*2.0f),ff2));
        }
      }

    } else 
    {
      float shw = pol.x < 0.5f ? 0.4f : 0.15f ;
      col -=  shw * d1;         // empty houses
    }
  } 

  // postprocessing

  col /=1.1f-0.2f;
  col += mix(0.15f * S(0.0f,6.0f,length2f(uv*s)), -0.8f * S(0.0f,6.0f,length2f(uv*s)), sun);
  col = clamp(col,to_float3_s(0.15f), to_float3_s(1.0f));
  float3 day = col;
  float3 night = col;
  night = mix(day, to_float3(0.2f,0.5f,0.9f),0.5f);

  night = pow(night, to_float3_s(3.0f));
  night += SAT(lights);
  night += SAT(blights)*4.0f ;

  float3 final = mix(day,night,S(-1.0f, 1.0f,sun));


  // color output

  fragColor = to_float4_aw(final,1.0f);
  
  //##########################################################################

  _tex2DVec4Write(dst, x, y, fragColor);
  
}

]]



-- // ------------------------------------------------------------------------
-- // Create
-- // ------------------------------------------------------------------------

function Create()

  ----- In/Out
  InImage1 = self:AddInput("Image", "Image", {
    LINKID_DataType = "Image",
    LINK_Main = 1,
    INP_Required = false
  })

  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main = 1,
  })

  ----- Inspector Panel Controls

   InFreq = self:AddInput("Frequency", "Frequency", {
    LINKID_DataType    = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default        = 2.0,
    INP_MinScale 	     = 0.0,
    INP_MaxScale 	     = 5.0,
  })

 
  ------ Information

  InfoButton = self:AddInput("Info ...", "InfoButton", {
    LINKID_DataType = "Text",
    INPID_InputControl = "ButtonControl",
    INP_DoNotifyChanged = true,
    INP_External = false,
    IC_ControlPage = -1,
  })

  InShaderInfoBlock = self:AddInput([[Shadertoy <a href="https://www.shadertoy.com/view/]]..shadertoy_id..[[" style="color:white; text-decoration:none; ">]]..shadertoy_name
      ..[[</a> by <a href="https://www.shadertoy.com/user/]]..shadertoy_author..[[" style="color:yellow; text-decoration:none; ">]]..shadertoy_author..[[</a><br />]]    
      ..shadertoy_license.. ( shadertoy_license=="" and "" or "<br>" )..[[DCTLified and DaFused by <a href="]]..dctlfuse_authorurl..[[" style="color:white; text-decoration:none; ">]]
      ..dctlfuse_author..[[</a>]]..(dctlfuse_versionDate=="" and " v0."..dctlfuse_versionNo or "<br />Version 0."..dctlfuse_versionNo.." - "..dctlfuse_versionDate),"Label", {
    LINKID_DataType = "Text", INPID_InputControl = "LabelControl", LBLC_MultiLine = true, IC_NoLabel = true, IC_NoReset = true, INP_External = false, INP_Passive = true, -- IC_ControlPage = -1,
  })


  InNmbr73Logo = self:AddInput(
    "<center><a href=\"https://www.youtube.com/c/nmbr73\"><img width=\"200\" height=\"55\" src=\"data:image/png;base64,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"..
    "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"..
    "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"..
    "9uG79GQP70GQQhx48tWHzp0130bFhgRl1Va0qAiie9HiISM6VQR07/SSvAXb72Af/vJlRgpqVRrYDR6ulTUtZOkEgkcJwGuQ1Nrhha3iYx0CUsVCqUpWsoZ5kc+2yaneHxkjIlCia0jLplUkmK5TFUFLO87kmQiu68JsWUsjNBPg0TEpbALFvSHYRBcVCyWftGY1ob8yfz7p/0YIzw/+Ntf3/Xg10rlmjDTBVJKx715w0Dty9WyniqzFODVy1z7f7/FruFdhGE4HY+x6OrqJpd0SCuPztYcWBIbiWNZpG0LS4Dt2tR9j53jBR7bvZcgDHEssKXBDwKybc2cfd4FzJu/errSUUzniU3ni007X6tXLmXZ0oX3A6cJIcqNaW3IC6FBjDHmx6uPWPae3/5uw1JjgVQaW4KwbSJXxuzRMwgBiSHRlOHIRYvYuWMIPwxxLZdca46Orm7qpSK7JvNEUmIZg+Um8cIQdJwpnLDiLideZJHr6GFk9zBeEGJUQDLt0tndS1f3PKSIm9dpDBbw1HcigiSRsFi0cF4d+FoDHA35U8uMiJMQYqQtl/5cb3e7sqXEsW1c28a2JAnHJmHbuI6FZQtsW2LZEtcRrFw0jyXz+jE6TgNOpzLUKmWKxQLCShCEmkhYVGp18uUKFQVF32ekWGZ3oUpNONh2MqZ3lUEh8YOQFSuPIZNtm451COR0GyHxVNqAMKxevgjHsW8CbmxMZ0NeUIAAJNLp64466rD/l25KYNkSaQukBbYlsGyms3sltiOxLQtHaLJJE6WTFQAABS9JREFUl0N6u+lqawGhCUOfSrVGtrWdroFBZDKNm0gTIdFPJRdKCz/UeEoQYhGEAaGOU1kUcMjyI1hx+HEYE8fzRdxLYrowK5a+9hzzFw6OAV8UQgSN6WzICw4QIUTddZyPrl556CY34cRslm1hWRIpLSxL4FgSRwpsx8IxPq4QLOxqZbCnA4OhUCwShgqtDW66iUjaKBN/G650EgRegO2mMZaLr+Kvho6vH3dwlBhOOfkUEm7T0zEeoePUEiGwEXS25jj+hKPrQsqPAY3IYEP+PACZlqHOjrYL+1vSeSHi9p5xjYhBCINCMbRrBw8+fD/e1E6kgOZMhpUL+lnc10no+9RqNarVKoVCgVKpSjUIKVbK1Kol0AYjJU6qCcdJUqlU2Ds+jlJxO5nebIaXLV+K3tcROK6DZ7ra0XFtjj9mpbJt+xvAvwkhGpmJDXlhnfT9tIgxxtx9+FGr32c9vuXqzVt35MLAAwHje8f5jxtvYiJf4PDBbk5beAJ+5OM4Dt3trSxfMMDO0QnK5SJ2wibKR6goBDTluo8fBihtyO/eRVNTc9yMul7HsgTGKLqySV5z5GF0ZVOEgWSqWMJJZkAbBBa2ZXHi8atVKp36DvClhmnVkD87QJ4Bkp8tX7ZYDO/YdtWOHdtzo2N7+fn1/0FnVzfZZIaB1iZsKQjR2AKEUgx0tnHU8sU8tHEro3v2kHQTJJJJqtUKYRDgBz61Wh0pbMrlCgiBjjSWpehI26wa6GZRbxe1Uol8TRKGim1PPonlunR19/LGM16n2tpavgv8rRCi0pjChvxnmFj7QCKE+PfXvvbU95z0ihOnNqx/hKZUBiFtvHqN0YlC/L0hMma7JAJba5bN7+G0Y1dx2MJ+dBRSLBYplUrU6h5BGBGEAX7gEYQhtUoVo2rMy7gcNdjDku4OUskUTwztZs/IKCpSZLPNbNu8mTNee4rf3tZyJXBxAxwN+XPIQVXJGGOE1vrobdu2X/21r1668pHHNuMHHglh+ND5pzHYmaM2NcXeUplaGOKHIaWgTqlUZffEJJuH9jBVrFD1orhrfBSC0KQTFp3ZJAOtObqammhNJpnf30fdaeLB0SoDCxYyMDDAqiMO48RXnFSwbftTwHeFEF5j6hryogHIM4AyUKvVPnfttdf/1Xe+80N3dHycpb2tfOD8M7C9OqV6lXoYUfM9KkFAxfcoloqM7B2P4x9eHc8PINTYtqA5laCjKU1zOkWL69DZ0o5vWdy4fpiadHnlySfxrne9Uy1desjDQohPAncIIRrtEhvy4gTINEgSxpg1O3fu/Odrr71u1fe+e41c3t/GW049nowrCSKN5wdUvBgkpVKeqUKBqVIpbiujFVGkkWiyiSSt6RS5dIpcJstIsc5N6zaT6ezlk5/6O3PyK14xmk6nvwT8GCg02KqGvOgB8gyg5IIgOGNyYuIjt9/x66Nuuv56+8jBDg5f0ItWBq0NYRiRrxbJl6fwfJ9avY4KAyIvIOHYpBMuyXQzIYb1W0dJ9S7gIx/9qF68aNGuTDb7fSHEd4GdDa3RkJccQJ4JFOCIyYmJvxzetv2N5Up5YGr7FuGP78YSCr9epeZViXRI3Yu/TDL++twkKpFlwepjmbf4EBYvWpTv6Oq8y3XcnwD3AiMNYDTkJQ+Q/cDSDqwIw/BEo/ViKcTiyfG9A1Hg5QI/sBDguAljJ5JeW3vHboTYZdv2ZinlWmAdMCyEaPTrach/TYDsBxYBJAEXaJ7+DbH+KAAB4AshwsY0NOTFKv8fqmLpbYIYVvcAAAAASUVORK5CYII=\" /></center></a>", 
    "Nmbr73Logo", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    LBLC_MultiLine = true,
    IC_NoLabel = true,
    IC_NoReset = true,
    INP_External = false,
    INP_Passive = true,
    IC_ControlPage = -1,
    })

end



-- // ------------------------------------------------------------------------
-- // Process
-- // ------------------------------------------------------------------------

function Process(req)

    local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate") -- get the frame rate of the comp set in the preferences

    --This creates an image for us to work on.
    local imgattrs = {
        IMG_Document = self.Comp,
        { IMG_Channel = "Red", },
        { IMG_Channel = "Green", },
        { IMG_Channel = "Blue", },
        { IMG_Channel = "Alpha", },
        IMG_Width = Width,
        IMG_Height = Height,
        IMG_XScale = XAspect,
        IMG_YScale = YAspect,
        IMAT_OriginalWidth = realwidth,
        IMAT_OriginalHeight = realheight,
        IMG_Quality = not req:IsQuick(),
        IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
        }
   
    if not req:IsStampOnly() then
        imgattrs.IMG_ProxyScale = 1
    end
   
    if SourceDepth ~= 0 then
        imgattrs.IMG_Depth = SourceDepth
    end
    

    -- Extern Texture or create a new one
    if (InImage1:GetValue(req) ~= nil) then
        src1 = InImage1:GetValue(req)
    else
        src1 = Image(imgattrs)
        local p = Pixel({R=0,G=0,B=0,A=0}) -- Initial black Image to avoid see random picture from Memory
        src1:Fill(p)
    end

    local dst = Image {IMG_Like = src1, IMG_DeferAlloc = true} -- create an Output Image


    -- Interface for running DCTL-Code

    node = DVIPComputeNode(req, "FavelaKernel", FavelaKernel, "FavelaParams", FavelaParams)


    if not pcall(function ()  -- necessary to avoid memory leakage 
        params.freq         = InFreq:GetValue(req).Value
        params.compOrder    = src1:IsMask() and 1 or 15
        params.width        = src1.DataWindow:Width()
        params.height       = src1.DataWindow:Height()
        params.iTime        = req.Time / framerate        
        node:SetParamBlock(params)        
    end) then   
        params              = node:GetParamBlock(FavelaParams)
        params.freq         = InFreq:GetValue(req).Value
        params.compOrder    = src1:IsMask() and 1 or 15
        params.width        = src1.DataWindow:Width()
        params.height       = src1.DataWindow:Height()
        params.iTime        = req.Time / framerate        
        node:SetParamBlock(params)
    end


    node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)

    node:AddInput("iChannel0", src1)
    node:AddOutput("dst",      dst)

    local success = node:RunSession(req)
    if not success then
        dst = nil
        dump(node:GetErrorLog()) -- Errormessages from DCTL-Compiler
    end
    OutImage:Set(req, dst)
end



-- // ------------------------------------------------------------------------
-- // Callback
-- // ------------------------------------------------------------------------

function NotifyChanged(inp, param, time)
	if (param ~= nil) then
		if (param.Value == 1) then
			if (inp == InfoButton) then
				bmd.openurl(dctlfuse_infourl)
			end	
		end
	end
end
