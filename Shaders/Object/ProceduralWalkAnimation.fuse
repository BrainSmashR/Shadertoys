--[[--
ProceduralWalkAnimation

    Based on https://www.shadertoy.com/view/WlsSWS a WebGL
    shader from shadertoy.com converted to DCTL and embeddet
    into a Lua Fuse by JiPi (https://www.youtube.com/c/JiPi_YT)
    for use in DaFusion.

    Shader created by TLC123


--]] --

-- MANDATORY -----------------------------------------------------------------
local shadertoy_name       = "ProceduralWalkAnimation"
local shadertoy_author     = "TLC123"
local shadertoy_id         = "WlsSWS"
local shadertoy_license    = ""
local dctlfuse_category    = "Object"
local dctlfuse_name        = "ProceduralWalkAnimation"
local dctlfuse_author      = "JiPi"
-- OPTIONAL ------------------------------------------------------------------
local dctlfuse_versionNo   = 1
local dctlfuse_versionDate = "9st of June 2021"
local dctlfuse_authorurl   = "https://www.youtube.com/c/JiPi_YT"
local dctlfuse_authorlogo  = 'width="259" height="60" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQMAAAA8CAYAAABiit8HAAABhGlDQ1BJQ0MgcHJvZmlsZQAAKJF9kT1Iw0AcxV9Ta6VUROwg4pChOlkQFXHUKhShQqgVWnUwufQLmjQkKS6OgmvBwY/FqoOLs64OroIg+AHi5uak6CIl/i8ptIj14Lgf7+497t4BQr3MNKtrHNB020wl4mImuyoGXxFAPwYQQrfMLGNOkpLoOL7u4ePrXYxndT735+hVcxYDfCLxLDNMm3iDeHrTNjjvE0dYUVaJz4nHTLog8SPXFY/fOBdcFnhmxEyn5okjxGKhjZU2ZkVTI54ijqqaTvlCxmOV8xZnrVxlzXvyF4Zz+soy12kOI4FFLEGCCAVVlFCGjRitOikWUrQf7+Afcv0SuRRylcDIsYAKNMiuH/wPfndr5ScnvKRwHAi8OM7HCBDcBRo1x/k+dpzGCeB/Bq70lr9SB2Y+Sa+1tOgR0LcNXFy3NGUPuNwBBp8M2ZRdyU9TyOeB9zP6piwwcAuE1rzemvs4fQDS1FXyBjg4BEYLlL3e4d097b39e6bZ3w/7WnJ3kCw/5wAAAAlwSFlzAAAOxAAADsQBlSsOGwAAAAd0SU1FB+UFERMQKMsPOJkAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAYeUlEQVR42u2dfXRW1b3nP/uc87wnT5KHBEIS8g4pBEFMBLEWgYte6bW39bXS6q2zLNTxeltn3enQuavWttNpbZdtdTqdVjreVVu7bou2eu8M5YpUBXE0FFB5DyQBkpAE8vK8v5zXPX+kIloICUIS6PmslZU8ec7e55y99++7f/t39tkbxpHFjddIXFxcJiXqeJ1oWcNyWV1Yi2JovX3p3p1u0bu4TC6UM/1z6bzrZFPl/DUX6iTzS69a4Q8FORLr4O2TO9e5xe7icomIwQxRQzUzn7xQJxEEX1JCfrYdeE24Re7icgmJQetQB7kC+4KdJL+0kOMDx93SdnG5FJk3a0HtsuYb5UfKmj70cGHF0k+7gUMXl0vRMwDYfeitjrRhM3Vq5YcaLjQ1L5YZJ+mWtIvLJEcb6cvtu/8gbviru0bVq89deI20bPtZj6KskKbRvPfttzoA5i75a57+wdfdWMFfOA8++KD8zne+c37DzPz8c7afZDJ5qp0KIZBy5Gbb2dlJY2PjiPl+85vflA899BBSShzHOfX7TH+f/nmk74V475SWZZFIJEgmkySTSfbt28fOnTvZsGHDh7KXdevWyVWrVo0pzf333z+yGAC89Idfixtuu1e+9Nufn7rApts+JWsWLKG2cgH1U2oo1rz4pCRr2XcMqIIer93enDtJ1skwtaIUfvB11xpcyMvLu+Tyzs/PH/dySiQScsOGDaxfv54XXnhBjFd5aKM5yAkGufk//xc5hGRO841E/GXMDxWwIGRTlQ+esCDn0ZCWQi6R4WhPipZ+nb2Kl4PZJCsffEhu/J+Pu96Bi8soCIfDrFq1ilWrVrF161b5yCOP8Oqrr150+xmVGLzZvp3/9PdPc6jXIJQz+duyEIuqw2hFQSxNRQD5EpCScIXD1Dk2ddEMG/54mDcO99M9/1pm3j4kDz/3C1cQXFxGgZQSIQRLlixhw4YNfO1rX5Pf//73L6r9KKO6sPxSTu5ro6zvBJ+aVcmiK6vQSvxITaDlILWrh+hL++l/dS/ypA7SS6Qon7uuqeHO6QkGEkHmLrjerWEXl1FyetwjGAzy2GOPsWbNGjnhYjBlwTLsnEljvs1H505D9QC2B9Gv0P1aOx7LQ+H0UkpmVLL/lTfoe6sNYat4VT9X1zUwTzGZqgiuWvG37iNGl4vam15ugnD6fX3ve99j2bJl8mKV26jEoKqmkeOtB1g8uwqPlsHBBAv6txyg8JjF84//C39326f53tovUlvg59Af3oABgABWvpdbaiuxTwxQMXMuhQ3zV7jN1uVi96aXoygUFBTwwAMPXHCBfDf/UYlBiW3idPdS7BGgZNAxwIDU28d5fdPLfOdf/xfr+3fyPzb+jh8/8b+ZnlfI3u1bQdGxpcSfieETgmmVs9BF6CW32bqMtiGP1bhPf3Q3UtrTj7uUvJrbb7+d5cuXy9HmN5b7PGcA8YqFH5XZI0eI+H3Ekgn8WR9qAJAhDF3HNh18Qo2q0ipyBKRTWXInYgQiIWQ2y0A2QdZOI1SLokgeCMNt5S4XHF3Xz0swJlvvPxruuusuXn755XOWh6IoYxLTcz9NcATpkwnKQyH6Y0OIPhU138JvKvjKYb5Wwj/Glhbtb99H1ZQSVly9lG173ua2O5bRF08QjSeIJYawhCS/MALC57Zcl1EbiGVZozrW7/dPGgtPpVL8+te/RkqJruvouk44HKayspKKigoaGxs/VP7XXnvtiN+vWbNGrFkz9rcIzikGe3ZsE5+96e9ldqiNlKYSjOeQOYGhSKZeP4tj//oKyxvm8ZkrbwZH5f927qBs5UK682LEkwkGB9Mcj1koTjGpbvDpAbJuO3e5wO7zZGP16tVnFadFixYNrV69uui+++47r7wbGxtZtGjRUEtLS+RCXvOo5hkodgWpzFEyaQMjA17hwSoQxAs8VN13Ez1/7KDjeIKUlaTiU3+FLPHROxAj3j9IT+cxjsbLyS+spfWtLjSj0G3hLqPGcZxL0qMZiZaWlkhLSwuHDx+Wjz766HkJZENDQ1FLSwvjLgb7j/iZPX0xR7sT5IVUpuSp+FDxoyJCKjOWfwTTkuR0k0Q6TjSVIJGGzr48uvpnMqDfTGdPL+379+LD67ZwlwvuGdx9993yTGlHMsxnnnlGTOQ1f/e73xU33nijXL58+ZjFZqRp0itWrJClpaVjut5f/epXYlRi0LdvF1O1G9ncF+Jgp+SqK2yqykyCfgW/L4RQFSxTEo1L+gaK6O4TdPbaRAcCpBJe4oMwNJDB7y3GkW7MwOXCewa//OUvx5Tv/v37eeaZZyb8/vbs2cNoxeB0cQuHw2c97s4772T16tVj1rDRvZuQTNDb3ovmn00yWcihNtA0E00oeDwqCJDSwbbA0AW5LOgZSS4F2YyBJQVF4QiOAVi628JdJnyYMFliEe3t7eeVLhAIjFo4LugwwTFPoNomuahCcgAUDTweiaJIhJBoikBB4Fhg5AS6AbZtoSgKAY8XqTnEB/uID3VQWOR6Bi4X3mjH2vgny+PFqqqqUd/b6dccj8cv+P2NSgxUJ59M0kLRQBGAA4qtoiFRFIEiQUpQJGgKoDnYUmAbEss0yTk7MdJeNGs+kcB0Qg2O3Nv6tPvSkssFE4OxNP7J9IRi3rx553VviUTigl/LqMTA45sPdimO40H1gOoBTRWoKCgOIB0EYFkg5LCXIBFIbGzbRnNUHEUnL6+I4rx5RIquYVpBk+waeJZDHe4iqS7jO0yYLF7BF7/4RXnDDTecV9qLIQYjTkeurly446or7pQzCm4iT9QQlBpeW6I5gCkRzrBLoDoKiq3gkQLNkXht8DoqmuOgoqOhkueZRnXFXArCgpLyKI898Q/814f/iY80Nj/qNnmX8Y4ZTDSPPPKI/Pa3v31eaS3L4je/+c0FV7SzegY1M5ofrS7+D00loZsxTC9ZVZLRHSzHRpUayGGvQCgSRQGJxNZAEwqmLbFtCxyBongJevMpCdVS5IWs1cqnV9dhaMfoavNx3dx/XCty/7z2QPtLrofgMqld+rGwevVqadvDK4yrqkpJScmpn5UrVxKJnP98oQs9v+CcYlBfvnJtVcHHSfRWECp/m9tWXkn3cYWtW3rRjQIcGRx2uRQQQqIIUKWCKR1AoikKmkdFk4K8knwKFciloLTOQ3F1kNde28mObZ1M88/mmlm3cqDdfX/JNerLwzMIhUKsW3fx9gp6/fXXL0q+ZxwmLP7Il+TMyO3ET0gS6R7sYCcls+N84j5JzfyDBINR8jUIKeATJl4svFLBI8ErbIKKQ9CrEM5zKCmV5BX0sOIGyCkbWPLJfAaz3fS0pdFOlDIzeDVGPERNZdMa12RcMbgcxOBixiQ6OjpYu3atGDcxaG4u4p/+2zyuumkPb/St4qWXf0HaOETK7iBcBJgGqsmw8Ss2fgX8EjQHvIDfKynKh0hQhZyJYe/mY7fA39xbQvOcCnpe0fG3N7Ng1idoPXmQd7o3cqTT3XbNFYPLZ5hwsfjRj3500fL+MzGondG0Jh6byr9v6uITt67k9nvqMeI2GzZsIK3H8Pgs0rF+FINhQbAkmm3jFRBQIaAIfI6KE7cwYzFKQgYzcvV0vQiRY038/r9L9vzbXLqOFLPr6BZaDj9JRh6sc6v58uZyDQSOJ08//TSPP37xFhb+s5iBFLB3dzuBdA/p/XncEHmcvEVbGNq3F73Vz1RZgJZppXBaHvOb59B7Mo6aCxFWAgQ8EAxIfJqF3+tHqIVkLZ0h/Tre+GOObFaQigUZ7M8Q1fcyILeS8eylo2t4jwWXv1zP4HxmzP0lsXnzZu69996LWkB/JgZHOneuO8LOdTqtsn/gQaZ5/pr8ohuoD6zk4G9VvF6HO5YtwKcJPLrJ1MISLASmdDBsQcZSiekqVgZMG3TDi5GBZEYQi2bJJNIUhINMKQgTi6v4RNCtaVcMzioErkDAc889xx133DFxS6Vn5fG6tv7/0+6t0MieuB5VCDQPeLzg9Sl4fQKPJlC14SmJwpHgKNiWwHIklumgZ0HPOiSzgK6Q7w9TWiOJZXtpb+uhfNrHKAtHMGV0R9vx7c2uybgxAzdm8H6+9a1v8fDDD4+LIp5VDDq63uqYXTIXwxrEb4GiCKQDuikw9OHHiaoQqJqDRwUQ4EgcW+A4EscB25ZoQqMgEidsFSAk9KY6ORJtIaWnuH7azZRWz6I//WZTG9tdi3FjBi7AoUOHePbZZ/nqV786rm7R2ecZVDQ/WiBq8ObqyKayaHlBNEUgJWALpFCG5xg4wxOOVFWgqgKhnK7owx8c4cfMQSxh0KMPb7umqTFmzvBTXpDPqoWfI2f2yJYj7sSjS41bbrlFVlVVnTOwNZK7/5cWL7Asi2w2SyKRIJvNntpn8e233+add95h8+bNE1IYZxWDSKBh7TWVdxJrbSBhZzANidenIhwHIUAKBw2BRwGvl2EhEMMvLEkpsG2JZYKpQzrnI53OkslGkVhoeHD8PuJmjko9n6vylxG8XkNiyu1HXnUFYRKxZMkSWV9fT319PTU1NdTX11NXV0dRUdGpY7Zv387jjz8+Yj4fXIzjdAEYSQii0eglV2apVGpUm8VONrQ/9wgW1M4puqP9immfQegzUEodMicVTFPHUhU86rBHoErxpzcYJbahYCvDlWtbYFkSyxSYxvDnrJ3GNMABhKIjlDS6rbP72FGKfSVUeaF2yhzuuf4f0HUh3+l5xRWECWLjxo2yrq6Ouro6FGVUK+mPamXiD4rBuTyBd8Wiv7/frZSJEoPZ01a2z5t6N0RnkE2DpRoU5ntJDCWxpQ8VgXAkQoBtDQ8b7D95BCCxLYFjK9g22NZw3MC2BCARqAghcNQ4GbGX/9d1AMvfyZyiRSysq+DKKZ9gaW0b7/S84tbMBNHQ0EBNTc2Y0oxmx9+RVuYZaVhx4sQJt1LGifdJ/8dqV8sF5Z/FTk5jMGkyaA5w7OQ+2hL/AuFOHJlGQaAK5dR+85YpsA0wDYmhDw8NHAscy8ZBYiFw1GGVV4WGonkw5CB24MDOfSd/Jvb2/juH+o6RTEPA8XB1w0K3ViaQPXv2jDnNggULznnM/Pnzz+t6uru73UoZbzGYXXGt/Ojsz6LF5pBOeulIbeOt1NfZp3zhCwljL6o/geHkcOTwy0mK+if1lmA77+1+IyU4yOFVUKSD5oCiKCiqD6EqmMRJc5S249ubq2cWrIlm24maAxzogQN9kDDLWFx3izsHdQLF4Hwe533pS186a6Lm5uZHR/ve/gfP3dHhzkcbdzGYOf06AqKeTA6S9iCDuZ0knF3Y/o7N2PkoIoQivMPDAQGKaqNqElVj+LcqUFUFVQXNA4rqoGgCqUqEYiEUG0tNkbAPo9MFwNHD8XW2J1bXHn+VfdF97GqHva0qmVzArZkJYvfu3ecV2b/nnnvO+t199923dqzDg3dFwRWDcRaDmWXXyeppi8ilvRgWpPUUvrwgQvFwpC3aEfIV4/WF8Pp9vPu0WBEqHk3g8Up8foHmkwgvKB5ACBACBzAVBwuDnDZAVusma518X2PziML2uTXXU1XciKNCWpwgY5+gembYXfRkAli/fr0wjLFvgdfU1ERLS4v85Cc/eaprX7ZsmfzpT38q77///vf1+CN5HqfvETg4OMjvf/97N5g8TmgAxZ56SsIzGYjpHDnRji/spXbqlQy0bwEglFdLKBABxYuZguENrwT8aW4BgOKoqLaDDTgOGEKiCx1TMbFVEwUF1dLw+EIgPacuYHp+I5FAA7Y5LE3RWB+O0AHVfYtxgvjd737HXXfdNeZ0Cxcu5IUXXmBoaEhqmva+oOHpHcDZPI8PzjfYunWrWxnj6RnMLF+4o7TwSnKxAgzLYSjXQTzXjRASn3e4Mr3+GZiKh0CBpGA6BIsdtCAo2vAqqIpHIj0WQhU4isDxDP8ILyh+ieKTKH4Tj8+D11uAorwXfU5kEwwlcyQsMLxH6U1sQ6jpuqOHo65/OEE8//zzHyp9JBIZ89ODM4nExo0b3coYT89AojRlMirJpApSIz/sRSmIsvvIdjJy2B6doEJOSrwm+FXwBxQIDE89tiwwbQdHgK1aOKhYjsDRTGxp4DgGUsti2wJbkcOLqKbfq/S32n8hcrJH5oUi2GaKXV2uWzgZhgoPP/ywbGxsHNeZgad7Bu3t7fzsZz9z28J4ikHb8TdFG2/SZ22RNcHPUFu1mKh1gNaTB2jreVkAJJ3DhDzg2AKvnY8qBT4VVKGAB6QXbHt43wTHsbAsA0OmMZ0Ulp3FVuM4wo/tZHDsLI7y/kkqBzo2u5U+yXjuueeYO3fumI14rP87m2fw4x//2K2EiYgZALxz5DmRmXH00eNMX6vLHG09770nMJTdSUEELJEjY0cIaGGk5kcbjhbiSImtGNiqiW5lMdUshpPGdNI40sBSkuBY2FYK20xgy5Rb8pOcb3zjG6K+vl7efffdY3bvx/K/M7FhwwZ++MMfuh3ERIkBwOGuHV8BvvLBg6KJlyiISMJBDZ/Xg9QElmbgCA+g4AgLxzGwHR3LNjGtLJadwrZ0pGOBMLAVsElikQBh7nSLfvJzzz33iLq6Orl48eJReQNj9SLOlMeWLVu4+eabz1sITn8aca5jLnfGWkejmnzeefQN0XnsVaTSi+2LkgvE0QNxzEAcM5DA8iUxfUlMbxpLS+J4kzieNLaWxtKySC2HVFNYShpHFXh8kSbX1C4NvvzlL59xP8APKwRnymPjxo0sXbr0Q3kEH9yGbLSezOXIWO9zVGIws7ao1pFG1PE4OKqBpaQwRRxdS2F4MlhaBtuTw9Fy4DOQmomjGjhaDlszsDUHLSDwBbyo/nyC4enMqF5Q+27+117zMXfG4STl9ddfF/X19eLpp5/+0L3qmRrnu/k98cQTfPzjH3eHBhfQKxgrZxSD65aukZ/5ux/IK5tulQCHO6IdRVNqi0KhEoTqx+/3kzOGiCeOkEweI2fH0e0UOSdFxkxgCh0UhUikjEjRNMKRWiJTyvD5AgSDxZSWzwV1avusWUvlT37yonziJ1t45FvrXUGYxNx7773i85//PF1dXRfU7d62bRu33347Dz30kCsEEzQ8OGPMAKBp4efk/Ob/iK0UM9szB5spMp5op3bWEoL5U0kkbXQjQS5n4vOGCBeEOH78MKowyQsXk8sYFE2Ziq7rhCNT8fsjpNMniccGEKrGDSuWMKehhMOtcxBolFVey8FDaebMuYnHfvCyHOzfR3v7W6xf/89u45hkPPXUU+Kpp57igQcekLfeeivNzc0UFBSMueENDQ2xadMmXnzxRX7+85+L8TSI8VhIZaJjEiPFZEYsL4D6hpvkdUs+h+Ktw3CGe36BTTabRtd1VNVDwJ9HTk9j2zr+YAifdwoSm77uXRw5/DKJxACz5ywhmQ4yd34z7R1tVFbMori4mlCeRTgYJh6LUTotRE2tB6+SwedVEMJPT2+Kkil5CGGhqRqdPSd48snH6Dj8h7rOY+7KyZOZG2+8UTY0NFBdXU1NTQ1FRUX4fD78fj8AsViMWCzGwMAABw4c4ODBg2zcuNEV+kmINqO6aU3jlZ8mUraMeCKDkThONnUS2/EzvayKggKNaKyHvt69DJ5owzRtamctJlJVTizeTyLZTzIVx+/3kssOYho5kqkYgUABsUSckmKdqukKpdPhWFeYXW+3kzVqKC1RqKn04/VCIJjHnv1RioqK0E2L3j4TSxQj8ayvryn8StuR2Ga3qiYnmzZtEps2bXIL4nIQA4BMNkEiEUXPmeiZNIaZo3jqVEpLy0gnU8TigkSsm8GBQ+SFyqgor0HVAji2iZHLoQg/08sKiEV3sHvHv4nk4MIdvkBVUyDvCirLQyiyCmmDYxkMDQ3S2q7g9VXj6wOPCoNxONydIXs4hSBBfHAPPZ1v0HXMXTHZxWXcxKDr6M51wby6J4unlKN6pmNJSCbSVJRLVOmgqSEEDqoawrQDlJZVAaDnbJKpLIgYwt7L1pfePOX6tR7Y3gzbKa/qlWXlfvKC9xFLwcn+IQb6u8jm4oSCPtKpaQg0YskY3ccOER1qxTE7ONHTQkfrVteVdHEZb8+gde96gX10R164oimXtTEth3DoGhRh4PXPRvXk4Q94CHhS9PfvIb+3lLz8BgwjjpmLcaT9zTMa7vFj28Tzx7Yx8DfT5YxpDt1Ht9HevodgfiV+z6eIRuegqH7isVZa9/+Wfbt+4QqAi8tEisHpvfm7SDspg6FqtLwwRjZKLtuDabbu3PXm9uZkfL8sr2gknRxi8MTBL5zrJK9tuOcDRv4mmojJ0vJrUISHgf532LfrOVcIXFwmkBENsH7W1evDhWV3SGziQ8frOtrcyL6Ly+XK/we8M0nmgAJ7dAAAAABJRU5ErkJggg=="'


-- // ------------------------------------------------------------------------
-- // Registry declaration
-- // ------------------------------------------------------------------------
FuRegisterClass( 
-- >>> SCHNIPP::FUREGISTERCLASS.version="MonumentsAndSites"
   (FC_PREFIX==nil and "ST_" or (FC_PREFIX=="" and "" or FC_PREFIX.."_"))..dctlfuse_name, CT_SourceTool, { REGS_Category = (FC_SUBMENU==nil and "Shadertoys (dev)" or (FC_SUBMENU=="" and "Fuses" or FC_SUBMENU))..(FC_CATEGORY==nil and "\\"..dctlfuse_category or ( FC_CATEGORY ~= "" and "\\"..FC_CATEGORY or "")), REGS_OpIconString = (FC_SCPREFIX==nil and "ST-" or (SC_SCPREFIX=="" and "" or FC_SCPREFIX.."-"))..shadertoy_id,
   REGS_OpDescription = "Shadertoy '"..shadertoy_name.."' (ID: "..shadertoy_id..") created by "..shadertoy_author.." and ported by "..dctlfuse_author..(shadertoy_license == "" and ". Copyright "..shadertoy_author.." (CC BY-NC-SA 3.0)" or ". "..shadertoy_license)..". This port is by no means meant to take advantage of anyone or to do anyone wrong : Contact us on Discord (https://discord.gg/75FUn4N4pv) and/or GitHub (https://github.com/nmbr73/Shadertoys) if you see your rights abused or your intellectual property violated by this work.",
   REG_Fuse_NoEdit = not(FC_DEVELOP==nil or FC_DEVELOP==true), REG_Fuse_NoReload = not(FC_DEVELOP==nil or FC_DEVELOP==true), REG_Fuse_TilePic = FC_TITLEPIC, REGS_Company = dctlfuse_company==nil and dctlfuse_author or dctlfuse_company, REGS_URL = dctlfuse_authorurl==nil and "https://nmbr73.github.io/Shadertoys/" or dctlfuse_authorurl,
   REG_Version = FC_VERSIONNO~=nil and FC_VERSIONNO or (dctlfuse_versionNo==nil and 1 or dctlfuse_versionNo),
-- <<< SCHNAPP::FUREGISTERCLASS

  REG_NoObjMatCtrls      = true,
  REG_NoMotionBlurCtrls  = true,

  REG_Source_GlobalCtrls = true,
  REG_Source_SizeCtrls   = true,
  REG_Source_AspectCtrls = true,
  REG_Source_DepthCtrls  = true,
  --REG_OpNoMask           = true,
  REG_TimeVariant        = true,
  REG_NoPreCalcProcess   = true,  -- call Process for precalc requests (instead of PreCalcProcess)
  })

dctlfuse_versionNo =  dctlfuse_versionNo/10

-- // ------------------------------------------------------------------------
-- // DCTL kernel parameters
-- // ------------------------------------------------------------------------
ProceduralWalkAnimationParams =
[[
  float center[2];
  float angle;
  float pivot[2];
  float debug;
  float scale;
  float freq;
  bool grdtex;
  bool fgrtex;
  float grdtexoff[2];
  float grdtexscale;
  float fgrtexoff[2];
  float fgrtexscale;
  bool head;
  bool ball;
  float look[3];
  float color[3];
  float color2[3];
  int width;
  int height;
  float itime;
  int compOrder;
]]


-- source of kernel
ProceduralWalkAnimationKernel =
    [[
//uniform float(TexOffX,0.0)
//uniform float(TexOffY,0.0)
//uniform float(TexScale,1.0)


//-----------------------
//-------- mat3 ---------
//-----------------------

//**** mat3 ****
typedef struct  
  {  

	float3 r0, r1, r2;  
  } mat3;  
 
__DEVICE__ inline mat3 make_mat3( float3 A, float3 B, float3 C)  
  {  
	mat3 D;  
	D.r0 = A;  
	D.r1 = B;  
	D.r2 = C;  
	return D;  
  } 
  
__DEVICE__ inline float3 mat3_multi_f3( mat3 B, float3 A) {  
	float3 C;  

	C.x = A.x * B.r0.x + A.y * B.r1.x + A.z * B.r2.x;  
	C.y = A.x * B.r0.y + A.y * B.r1.y + A.z * B.r2.y;  
	C.z = A.x * B.r0.z + A.y * B.r1.z + A.z * B.r2.z;  
	return C;  
  }

#if defined(DEVICE_IS_OPENCL) || defined(DEVICE_IS_METAL)
__DEVICE__ float3 reflect(float3 I, float3 N) {return I - 2.0f * dot(N, I) * N;}
#endif

__DEVICE__ float fract_f(float A){return A - _floor(A);}
__DEVICE__ float2 fract_f2(float2 A){return make_float2(A.x - _floor(A.x), A.y - _floor(A.y));}
__DEVICE__ float3 fract_f3(float3 A){return make_float3(A.x - _floor(A.x), A.y - _floor(A.y), A.z - _floor(A.z));}
__DEVICE__ float2 abs_f2(float2 a) {return (to_float2(_fabs(a.x), _fabs(a.y)));}
__DEVICE__ float3 sin_f3(float3 i) {float3 r; r.x = _sinf(i.x); r.y = _sinf(i.y); r.z = _sinf(i.z); return r;}
#define lpowf _powf
__DEVICE__ float3 pow_f3(float3 a, float3 b) {float3 r; r.x = lpowf(a.x,b.x); r.y = lpowf(a.y,b.y); r.z = lpowf(a.z,b.z); return r;}


#define swixy(V) to_float2((V).x,(V).y)
#define swixz(V) to_float2((V).x,(V).z)

#define swixyz(V) to_float3((V).x,(V).y,(V).z)
  #define swixxx(V) to_float3((V).x,(V).x,(V).x)
  #define swixyy(V) to_float3((V).x,(V).y,(V).y)
  #define swiyxy(V) to_float3((V).y,(V).x,(V).y)
  #define swiyyx(V) to_float3((V).y,(V).y,(V).x)


//#ifdef Simulate_fwidth
__DEVICE__ float2 _fwidth(float2 inp, float2 iR){
    //simulate fwidth
    float uvx = inp.x + 1.0f/iR.x;
    float ddx = uvx * uvx - inp.x * inp.x;

    float uvy = inp.y + 1.0f/iR.y;
    float ddy = uvy * uvy - inp.y * inp.y;

    return to_float2(_fabs(ddx), _fabs(ddy));
}
//#endif
// Fork of "Football" by . https://shadertoy.com/view/llKcR3
// 2019-07-25 21:23:38
// Modified from https://www.shadertoy.com/view/Xds3zN by iq.
//

/*
 Some path funtion: timefly(t) returns a 2d pivot
 pasaR(t) and pasaL(t) modifies time to get 
 initial foot targets when fead to timefly()
 
*/

#define AA 1
# define PI 3.14159265359f
# define PHI 1.618033988749895f
# define TAU 6.283185307179586f

struct Figur
{
	float3 rightFoot;
	float3 leftFoot;
	float3 rightToe;
	float3 leftToe;
	float3 rightHand;
	float3 leftHand;
	float3 rightFootT;
	float3 leftFootT;
	float3 rightHandT;
	float3 leftHandT;
	float3 rightToeT;
	float3 leftToeT;
	float3 rightE;  // Elbow
	float3 leftE;
	float3 rightK;  //Knee
	float3 leftK;
	float3 rightH;  //Hip
	float3 leftH;
	float3 rightS;  // Shoulder
	float3 leftS;
	float3 pelvis;
	float3 torso;
	float3 head;
	float3 target;

	float pasa;     // = 1.0f;    // steps overlaping airtime
	float legmax;   // = 0.89f; // max extention
	float leg;      // = 0.89f+0.005f; // actual max length
	float armmax;   // = 0.7f;// max extention
	float arm;      // = 0.7f +0.012f;// actual max length
	float toemax;   // = 1.1f;// max extention toe from hip
	float footlift; //=0.19f; //lift height later multiplied by speed
};

# define PLOTPATH 0
 

//------------------------------------------------------------------
__DEVICE__ float sdPlane(float3 p) {


	return p.y;
}
__DEVICE__ float sdSphere(float3 p, float s) {
	return length(p) - s;
}
__DEVICE__ float sdCapsule(float3 p, float3 a, float3 b, float r) {
	float3 pa = p - a, ba = b - a;
	float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0f, 1.0f);
	return length(pa - ba * h) - r;
}
__DEVICE__ float sdRoundedCylinder( float3 p, float ra, float rb, float h )
{
    float2 d = make_float2( length(swixz(p))-2.0f*ra+rb, _fabs(p.y) - h );
    return _fminf(_fmaxf(d.x,d.y),0.0f) + length(_fmaxf(d,to_float2_s(0.0f))) - rb;
}

__DEVICE__ float pathterrain(float x,float z){
    // Common height function for path and terrain

    return  _sinf(x*0.5f )*1.0f+_cosf(z*0.3f )*0.3f
           +_cosf(x*3.0f+z )*0.1f+_sinf(x-z*0.2f )*0.2f;
}
		
__DEVICE__ float3 timefly(float t) {
    // main path Called from many places
    t*=0.80f;
    t += (0.125f + _sinf(t * 0.125f));
    float3 v =	make_float3(_sinf(t / 50.0f) * 20.0f, 0.0f, _cosf(t / 25.0f) * 24.0f) +
	            make_float3(_sinf(t / 17.1f) * 07.0f, 0.0f, _cosf(t / 17.1f) * 05.0f) +
		        make_float3(_sinf(t / 8.1f) * 6.0f, 0.0f, _cosf(t / 8.1f) * 8.0f) +
		        make_float3(_cosf(t / 3.0f) * 3.0f,0.0f, _sinf(t / 3.0f) * 2.0f)  +
			    make_float3(_cosf(t  )*2.0f,0.0f, _sinf(t  )*2.0f );
    v.y=pathterrain(v.x,v.z);
    return v        ;
} 

__DEVICE__ float pasaR(float x, struct Figur *figur){
	return _fmaxf(x + fract_f(x + 0.25f) * (*figur).pasa - (*figur).pasa, _floor(x + 0.25f) - 0.25f) + 0.25f;
    //gait function 
}
    
__DEVICE__ float pasaL(float x, struct Figur *figur){
	return _fmaxf(x + fract_f(x - 0.25f) * (*figur).pasa - (*figur).pasa, _floor(x - 0.25f) + 0.25f) + 0.25f;
   //gait function 
}



__DEVICE__ float lpnorm(float3 p, float s) {
	return _powf(( _powf(_fabs(p.x), s) +
		         _powf(_fabs(p.y), s) +
		         _powf(_fabs(p.z), s)),
		         1.0f / s);
}

 
//------------------------------------------------------------------
__DEVICE__ float2 opU(float2 d1, float2 d2) {
	return (d1.x < d2.x) ? d1 : d2;
}

__DEVICE__ float s_fminf(float a, float b, float k)
{
	float h = clamp(0.5f + 0.5f*(a-b)/k, 0.0f, 1.0f);
	return _mix(a, b, h) - k*h*(1.0f-h);
}

//float3 perpr = cross(dirr,make_float3(0,-1,0));

__DEVICE__ float2 bodyPlan(float3 pos, float itime, struct Figur figur, __CONSTANTREF__ ProceduralWalkAnimationParams *params) {
	float res;
	res =  sdSphere(pos - figur.leftFoot, 0.07f);
	res = _fminf(res, sdSphere(pos - figur.leftHand, 0.06f));
	res = _fminf(res, sdSphere(pos - figur.leftH, 0.09f));
	res = _fminf(res, sdSphere(pos - figur.leftK, 0.08f));
	res = _fminf(res, sdSphere(pos - figur.leftE, 0.08f));
	res = _fminf(res, sdSphere(pos - figur.leftS, 0.07f));	

    
    res = _fminf(res, sdSphere(pos - figur.rightFoot, 0.07f));
	res = _fminf(res, sdSphere(pos - figur.rightHand, 0.06f));
	res = _fminf(res, sdSphere(pos - figur.rightH, 0.09f));
	res = _fminf(res, sdSphere(pos - figur.rightS, 0.07f));
	res = _fminf(res, sdSphere(pos - figur.rightK, 0.08f));
	res = _fminf(res, sdSphere(pos - figur.rightE, 0.08f));
    
	if (params->ball) res = _fminf(res, sdSphere(pos - figur.target, 0.2f));
	if (params->head) res = _fminf(res, sdSphere(pos - figur.head, 0.16f));

 	
    
    res = _fminf(res, sdCapsule(pos ,figur.rightToe,figur.rightFoot, 0.06f));
    res = s_fminf(res, sdRoundedCylinder(pos - figur.rightToe, 0.04f, 0.02f, 0.03f ),0.06f );

    res = _fminf(res, sdCapsule(pos ,figur.rightK,figur.rightFoot, 0.06f));
    res = _fminf(res, sdCapsule(pos ,figur.rightK,figur.rightH, 0.07f));   
    res = _fminf(res, sdCapsule(pos ,figur.rightE,figur.rightHand, 0.05f));
    res = _fminf(res, sdCapsule(pos ,figur.rightE,figur.rightS, 0.06f));
    res = _fminf(res, sdCapsule(pos ,figur.torso,figur.rightS, 0.08f));
    
    res = _fminf(res, sdCapsule(pos ,figur.leftToe,figur.leftFoot, 0.06f));
    res = s_fminf(res, sdRoundedCylinder(pos - figur.leftToe, 0.04f, 0.02f, 0.03f ),0.06f);// todo rotate to grund normal

    res = _fminf(res, sdCapsule(pos ,figur.leftK,figur.leftFoot, 0.06f));
    res = _fminf(res, sdCapsule(pos ,figur.leftK,figur.leftH, 0.07f));   
    res = _fminf(res, sdCapsule(pos ,figur.leftE,figur.leftHand, 0.05f));
    res = _fminf(res, sdCapsule(pos ,figur.leftE,figur.leftS, 0.06f));
    res = _fminf(res, sdCapsule(pos ,figur.torso,figur.leftS, 0.08f));
    
    res = s_fminf(res, sdSphere(pos - figur.torso, 0.14f),0.025f);
    res = s_fminf(res, sdSphere(pos - figur.pelvis, 0.16f),0.025f);
    
    res = s_fminf(res, sdCapsule(pos ,figur.pelvis,figur.torso, 0.13f),0.025f);
    res = _fminf(res, sdCapsule(pos ,figur.head,figur.torso, 0.02f)); 
    
    
    
    if(PLOTPATH>0)for(int i=PLOTPATH;i>-PLOTPATH/2;i--)

    {
        res = _fminf(res, sdSphere(pos- timefly(itime+(float)(i)*0.5f), 0.04f));
    }  

     //float x=itime;
     // res= _fminf(res, sdCapsule( pos, timefly(x),timefly(x+1.0f) , 0.06125f));
     // res= _fminf(res, sdCapsule( pos, timefly(x)-perpr*-0.25f,timefly(x)-perpl*0.25f , 0.06125f));
     return make_float2(res, 2.0f);
}

__DEVICE__ float2 map( float3 pos, float itime, struct Figur figur, __CONSTANTREF__ ProceduralWalkAnimationParams *params) {
	float2 res = make_float2(pos.y-pathterrain(pos.x,pos.z), 1.0f);
	res = opU(res, bodyPlan(pos,itime, figur, params));
	return res;
}

__DEVICE__ float2 castRay( float3 ro, float3 rd, float itime, struct Figur figur, __CONSTANTREF__ ProceduralWalkAnimationParams *params) {
	float tmin = 1.0f;
	float tmax = 30.0f;
	float t = tmin;
	float m = -1.0f;
	for (int i = 0; i < 80; i++) {
		float precis = 0.0001f * t;
		float2 res = map(ro + rd * t,itime, figur, params);
		if (res.x < precis || t > tmax) break;
		t += res.x * 0.7f;
		m = res.y;
	}
	if (t > tmax) m = -1.0f;
	return make_float2(t, m);
}

__DEVICE__ float calcSoftshadow( float3 ro, float3 rd, float mint, float tmax, float itime, struct Figur figur, __CONSTANTREF__ ProceduralWalkAnimationParams *params) {
	float res = 1.0f;
	float t = mint;
	for (int i = 0; i < 32; i++) {
		float h = map(ro + rd * t,itime, figur,params).x;
		res = _fminf(res, 8.0f * h / t);
		t += clamp(h, 0.02f, 0.10f);
		if (res < 0.005f || t > tmax) break;
	}
	return clamp(res, 0.0f, 1.0f);
}

__DEVICE__ float3 calcNormal( float3 pos, float itime, struct Figur figur, __CONSTANTREF__ ProceduralWalkAnimationParams *params) {
	float2 e = make_float2(1.0f, -1.0f) * 0.5773f * 0.0005f;
	return normalize(swixyy(e) * map(pos + swixyy(e),itime,figur, params).x +
		           swiyyx(e) * map(pos + swiyyx(e),itime,figur,params).x +
		           swiyxy(e) * map(pos + swiyxy(e),itime,figur,params).x +
		           swixxx(e) * map(pos + swixxx(e),itime,figur,params).x);
}

__DEVICE__ float calcAO( float3 pos, float3 nor, float itime, struct Figur figur, __CONSTANTREF__ ProceduralWalkAnimationParams *params) {
	float occ = 0.0f;
	float sca = 1.0f;
	for (int i = 0; i < 5; i++) {
		float hr = 0.01f + 0.12f * (float)(i) / 4.0f;
		float3 aopos = nor * hr + pos;
		float dd = map(aopos,itime,figur,params).x;
		occ += -(dd - hr) * sca;
		sca *= 0.95f;
	}
	return clamp(1.0f - 3.0f * occ, 0.0f, 1.0f);
}
// http://iquilezles.swiwww(org)/articles/checkerfiltering/checkerfiltering.htm
__DEVICE__ float checkersGradBox2( float2 p,float2 iR) {
	// filter kernel
	float2 w = _fwidth(p,iR)/10.0f + 0.001f;//make_float2(0.01,0.01);//_fwidth(p,iR)/10. + 0.001;
	// analytical integral (box filter)
	float2 i = 2.0f * (abs_f2(fract_f2((p - 0.5f * w) * 0.5f) - 0.5f) - abs_f2(fract_f2((p + 0.5f * w) * 0.5f) - 0.5f)) / w;
	// xor pattern
	return 0.5f - 0.5f * i.x * i.y;
}

__DEVICE__ float checkersGradBox( float2 p, float2 iR) {
	return  checkersGradBox2(p,iR) -checkersGradBox2(p-0.03f,iR )*0.4f ;
}

__DEVICE__ float3 render( float3 ro, float3 rd, float itime, float2 iR, __TEXTURE2D__ iCh0, __TEXTURE2D__ iCh1,float ratio, __CONSTANTREF__ ProceduralWalkAnimationParams *params, struct Figur figur) {
	float3 col = make_float3(0.7f, 0.9f, 1.0f) + rd.y * 0.8f;
	float2 res = castRay(ro, rd,itime, figur, params);
	float t = res.x;
	float m = res.y;
	if (m > -0.5f) {
		float3 pos = ro + t * rd;
		float3 nor = calcNormal(pos,itime, figur, params);
		float3 ref = reflect(rd, nor);
		// material        
		col = 0.45f + 0.35f * sin_f3(make_float3(0.05f, 0.08f, 0.10f) * (m - 1.0f));
		if (m < 1.5f) {
            
			if (params->grdtex)
			{
				float2 tuv = make_float2(pos.x/ratio,pos.z)/params->grdtexscale + to_float2_v(params->grdtexoff);
				col = swixyz(_tex2DVecN(iCh0, tuv.x,tuv.y,15));
			}
			else			
			{
							//Original
				float f = checkersGradBox(1.2f * swixz(pos), iR);
				col = 0.3f + f * to_float3_v(params->color);
			}

		}
		if (m >= 2.0f) {
			if (params->fgrtex)
			{
				float2 tuv = make_float2(nor.x/ratio,nor.y)/params->fgrtexscale + to_float2_v(params->fgrtexoff);
				col = swixyz(_tex2DVecN(iCh1, tuv.x,tuv.y,15));
			}
			else			
			{
				col = to_float3_v(params->color2); // Body
			}
		}
		if (m >= 3.0f) {
			col = make_float3(0.07f,0.0f,0.0f);    // Unknown
		}
		// lighting        
		float occ = calcAO(pos, nor,itime, figur, params);
		float3 lig = normalize(make_float3(0.2f, 0.7f, 0.6f));
		float3 hal = normalize(lig - rd);
		float amb = clamp(0.5f + 0.5f * nor.y, 0.0f, 1.0f);
		float dif = clamp(dot(nor, lig), 0.0f, 1.0f);
		float bac = clamp(dot(nor, normalize(make_float3(-lig.x, 0.0f, -lig.z))), 0.0f, 1.0f) * clamp(1.0f - pos.y, 0.0f, 1.0f);
		float dom = smoothstep(-0.1f, 0.1f, ref.y);
		float fre = _powf(clamp(1.0f + dot(nor, rd), 0.0f, 1.0f), 2.0f);
		dif *= calcSoftshadow(pos, lig, 0.02f, 2.5f,itime, figur, params);
		dom *= calcSoftshadow(pos, ref, 0.02f, 2.5f,itime, figur, params);
		float spe = _powf(clamp(dot(nor, hal), 0.0f, 1.0f), 16.0f) *
			        dif *
			        (0.04f + 0.96f * _powf(clamp(1.0f + dot(hal, rd), 0.0f, 1.0f), 5.0f));
		float3 lin = to_float3_s(0.0f);
		lin += 1.30f * dif * make_float3(1.00f, 0.80f, 0.55f);
		lin += 0.20f * amb * make_float3(0.40f, 0.60f, 1.00f) * occ;
		lin += 0.20f * dom * make_float3(0.40f, 0.60f, 1.00f) * occ;
		lin += 0.30f * bac * make_float3(0.25f, 0.25f, 0.25f) * occ;
		lin += 0.35f * fre * make_float3(1.00f, 1.00f, 1.00f) * occ;
		col = col * lin;
		col += 10.00f * spe * make_float3(1.00f, 0.90f, 0.70f);
		col = _mix(col, make_float3(0.8f, 0.9f, 1.0f), 1.0f - _expf(-0.0002f * t * t * t));
	}
	return (clamp(col, 0.0f, 1.0f));
}

__DEVICE__ mat3 setCamera( float3 ro, float3 ta, float cr) {
	float3 cw = normalize(ta - ro);
	float3 cp = make_float3(_sinf(cr), _cosf(cr), 0.0f);
	float3 cu = normalize(cross(cw, cp));
	float3 cv = normalize(cross(cu, cw));
	return make_mat3(cu, cv, cw);
}


__DEVICE__ void setup(float itime, struct Figur *figur) {
    float x = itime   ;//Time manipulations moved to timefly

    
    // filter gait slightly for less stabby foot placement, too much generates skating
    float filt=18.0f;
    float left = 0.025f+ _mix(pasaR(_floor(x*filt)/filt, figur) ,pasaR(_ceil(x*filt)/filt, figur), ( fract_f(x*filt)));
    float right =0.025f+ _mix(pasaL(_floor(x*filt)/filt, figur) ,pasaL(_ceil(x*filt)/filt, figur), ( fract_f(x*filt)));
	
    
    float ahead=1.1f;
    float3 dif = (timefly(x + ahead) - timefly(x))/ahead; //delta x+1
    float speed = length(dif); 
    ahead = clamp(0.8f,1.1f,1.3f-speed);
    dif = (timefly(x + ahead) - timefly(x))/ahead; //delta x+1
    speed = length(dif); 
    
    
    float3 nextdif = (timefly(x + ahead+0.5f) - timefly(x + 0.5f))/ahead; 
    float3 lean = (nextdif - dif*2.0f); // bank into turns

    ahead=speed;
    dif = (timefly(x + ahead) - timefly(x))/ahead; //delta x+1
    nextdif = (timefly(x + ahead+0.5f) - timefly(x + 0.5f))/ahead; 
    lean = (nextdif - dif*2.0f); // bank into turns
   
    float nextSpeed = length(timefly(x + 1.2f) - timefly(x + 0.2f));
 
    float3 dir = normalize(dif); //Path direction 
    float3 nextdir = normalize(nextdif); //Path direction 
    float3 dirr = normalize(timefly(right + 1.0f) - timefly(right)); //Path direction Foot specific
    float3 dirl = normalize(timefly(left + 1.0f) - timefly(left));
    
    float3 perp = cross(dir,make_float3(0,-1,0));// perpendicular to main path
    float3 perpl = cross(dirl,make_float3(0,-1,0));// perpendicular to intervalled step path
    float3 perpr = cross(dirr,make_float3(0,-1,0));
    
    (*figur).target =(timefly(x+1.5f)) + (make_float3(0,0.4f,0)+lean*1.6f+dir*0.25f )*(0.09f/clamp(speed , 0.05f, 4.5f));// rolling head
       
    (*figur).target.y=pathterrain((*figur).target.x,(*figur).target.z);// fix for rolling head collision 
    
    (*figur).target +=  ( make_float3(0,0.14f+_fabs(_sinf(x*7.0f)*0.3f),0)) ;

    float3 tfx= timefly(x)  ; // Pelvis   path
    float3 tfr= timefly(right) ;//intervalled step path
    float3 tfl= timefly(left) ; //intervalled step path
    
    // foot lift component
    float3 leftlift = make_float3(0, _fminf(0.0f, _sinf(x * TAU + 1.57f) * (*figur).footlift * clamp(speed, 0.05f, 1.5f)), 0);
    float3 rightlift = make_float3(0, _fminf(0.0f, _sinf(x * TAU - 1.57f) * (*figur).footlift * clamp(speed, 0.05f, 1.5f)), 0);
 
    
    // setup targets
    (*figur).rightFootT = tfr + perpr * -0.16f - rightlift;
    (*figur).leftFootT = tfl + perpl * 0.16f - leftlift;
    (*figur).rightToeT = tfr  + perpr * -0.19f  +dir*0.172f - rightlift*0.6f;
    (*figur).leftToeT = tfl  + perpl * 0.19f  +dir*0.172f- leftlift*0.7f;
    // ground collision feet and toes
    (*figur).rightFootT.y=_fmaxf(pathterrain((*figur).rightFootT.x,(*figur).rightFootT.z),    (*figur).rightFootT.y);
    (*figur).leftFootT.y=_fmaxf(pathterrain((*figur).leftFootT.x,(*figur).leftFootT.z),    (*figur).leftFootT.y);
    (*figur).rightToeT.y=_fmaxf(pathterrain((*figur).rightToeT.x,(*figur).rightToeT.z),    (*figur).rightToeT.y);
    (*figur).leftToeT.y=_fmaxf(pathterrain((*figur).leftToeT.x,(*figur).leftToeT.z),    (*figur).leftToeT.y);
    
   
	(*figur).pelvis = tfx 
            + (lean  ) * clamp(nextSpeed, 0.01f, 0.5f) * 0.1f 					// lean into turn
            + make_float3(0, 0.9f + _cosf(x * TAU * 2.0f) * 0.02f * speed, 0) 	// bob u/d with step
		    + dir * 0.1f * (-0.45f + speed) 									// lean to run
		    + perpr * _sinf(x * TAU) * 0.025f * speed 							// bob l/R with step
 		    + (make_float3(0,-1.0f,0) )*(0.02f/clamp(speed , 0.15f, 4.5f));		// bend when head is close

    // spine component
    float3 spine = normalize(
		    (lean  ) * clamp(nextSpeed, 0.2f, 0.5f) * 0.1f 					// lean into turn
		    + make_float3(0, 0.3f + _cosf(x * TAU * 2.0f) * 0.0125f * speed, 0)	// bob u/d with step
		    + dir * 0.05f * (-0.25f + nextSpeed)  								// lean to run
            +(make_float3(0,-1.0f,0)+dir)*(0.05f/clamp(speed , 0.15f, 4.5f))	// bend when head is close
            + perpr * _cosf(x * TAU) * 0.025f * speed);							// bob l/R with step
	
     
    (*figur).torso = (*figur).pelvis + spine * 0.3f;
    
    

    // Hips
    (*figur).rightH = (*figur).pelvis + perp * -0.11f - rightlift * 0.1f - spine * 0.08f + dir * -0.025f;
    (*figur).leftH = (*figur).pelvis + perp * 0.11f - leftlift * 0.1f - spine * 0.08f + dir * -0.025f;
    
    // Feet
    (*figur).rightFoot = (*figur).rightH + normalize((*figur).rightFootT - (*figur).rightH) * _fminf((*figur).legmax, length((*figur).rightFootT - (*figur).rightH));
    (*figur).leftFoot = (*figur).leftH + normalize((*figur).leftFootT - (*figur).leftH) * _fminf((*figur).legmax, length((*figur).leftFootT - (*figur).leftH));
	
    (*figur).rightToe = (*figur).rightH + normalize((*figur).rightToeT - (*figur).rightH) * _fminf((*figur).toemax, length((*figur).rightToeT - (*figur).rightH));
    (*figur).leftToe = (*figur).leftH + normalize((*figur).leftToeT - (*figur).leftH) * _fminf((*figur).toemax, length((*figur).leftToeT - (*figur).leftH));

    // Shoulder
	(*figur).rightS = (*figur).torso + perp * -0.2f   + spine * 0.05f;
	(*figur).leftS = (*figur).torso + perp * 0.2f  + spine * 0.05f;
    
    // Hand Target
    (*figur).rightHandT=((*figur).rightS +  normalize(
			perpr * -0.06f 
			+make_float3(0, -0.4f, 0) 
			+dir * 0.3f * _cosf(0.25f + x * TAU) * (clamp(speed, 0.0f, 2.0f) * 0.25f)) 
            * (*figur).armmax 
			+make_float3(0, 0.2f, 0) * clamp(speed - 0.6f, 0.0f, 1.0f) )				// lift alittle with speed
        	      + ((*figur).target -(*figur).rightS)*(1.0f-smoothstep(0.0f,1.2f,(1.0f+_sinf(x*1.0f ))))*0.3f;	// reach for head 
    
    (*figur).leftHandT= ((*figur).leftS + normalize(
			perpl * 0.06f +
			make_float3(0, -0.4f, 0) +
			dir * 0.3f * _cosf(0.25f + PI + x * TAU) * (clamp(speed, 0.0f, 2.0f) * 0.25f)) 
			* (*figur).armmax 
			+ make_float3(0, 0.2f, 0) * clamp(speed - 0.6f, 0.0f, 1.0f))
			+ ((*figur).target -(*figur).leftS)*(1.0f-smoothstep(0.0f,1.2f,(1.0f+_sinf(x*1.0f+PI))))*0.3f;
    
    (*figur).rightHand = (*figur).rightS + normalize((*figur).rightHandT - (*figur).rightS) * _fminf((*figur).armmax, length((*figur).rightHandT - (*figur).rightS));
    (*figur).leftHand = (*figur).leftS + normalize((*figur).leftHandT - (*figur).leftS) * _fminf((*figur).armmax, length((*figur).leftHandT - (*figur).leftS));
 	
     
    (*figur).rightHand.y=_fmaxf(pathterrain((*figur).rightHand.x,(*figur).rightHand.z)+0.2f,    (*figur).rightHand.y);
    (*figur).leftHand.y=_fmaxf(pathterrain((*figur).leftHand.x,(*figur).leftHand.z)+0.2f,    (*figur).leftHand.y);
 
    
    
    (*figur).head = (*figur).torso +normalize(
		make_float3(0, 0.27f, 0) 
		+ normalize(lean) * clamp(nextSpeed, 0.2f, 1.0f) * 0.05f // lean into torn
		+dir * 0.1f * (-0.35f + clamp(speed, 0.5f, 2.0f)) // lean into run
		+perpr * _cosf(x * TAU) * 0.025f * clamp(speed, 0.5f, 2.0f)
        +(make_float3(0,-1.0f,0)+dir)*(0.07f/clamp(speed , 0.05f, 4.5f))// bend when head is close
        )*0.27f;// sway with step
    
    // bendy lims IK

	(*figur).rightE = _mix((*figur).rightS, (*figur).rightHand, 0.5f) - cross((*figur).rightS - (*figur).rightHand, -1.0f*normalize(perp - dir * 0.5f)) *
		     _sqrtf(_fmaxf(0.0001f, (*figur).arm * (*figur).arm - length((*figur).rightS - (*figur).rightHand) * length((*figur).rightS - (*figur).rightHand))) * 0.5f;
	(*figur).leftE = _mix((*figur).leftS, (*figur).leftHand, 0.5f) - cross((*figur).leftS - (*figur).leftHand, -1.0f*normalize(perp + dir * 0.5f)) *
		    _sqrtf(_fmaxf(0.0001f, (*figur).arm * (*figur).arm - length((*figur).leftS - (*figur).leftHand) * length((*figur).leftS - (*figur).leftHand))) * 0.5f;
	(*figur).rightK = _mix((*figur).rightH, (*figur).rightFoot, 0.5f) - cross((*figur).rightH - (*figur).rightFoot, normalize(perp + dir * 0.25f)) *
		     _sqrtf(_fmaxf(0.0001f, (*figur).leg * (*figur).leg - length((*figur).rightH - (*figur).rightFoot) * length((*figur).rightH - (*figur).rightFoot))) * 0.5f;
	(*figur).leftK = _mix((*figur).leftH, (*figur).leftFoot, 0.5f) - cross((*figur).leftH - (*figur).leftFoot, normalize(perp - dir * 0.25f)) *
		    _sqrtf(_fmaxf(0.0001f, (*figur).leg * (*figur).leg - length((*figur).leftH - (*figur).leftFoot) * length((*figur).leftH - (*figur).leftFoot))) * 0.5f;
} 

__DEVICE__ float2 spin(float2 uv, float2 center, float angle, float aspect)
{
  float C = _cosf(angle);
  float S = _sinf(angle);
   
  uv -= center;
  float x = uv.x;
  uv.x = (x*aspect * C - uv.y * S);
  uv.y = (x*aspect * S + uv.y * C);
  uv += center;
   
return uv;
} 

//############################################################################################################################
__KERNEL__ void ProceduralWalkAnimationKernel(__CONSTANTREF__ ProceduralWalkAnimationParams *params, __TEXTURE2D__ iChannel0, __TEXTURE2D__ iChannel1, __TEXTURE2D_WRITE__ dst)
{
  DEFINE_KERNEL_ITERATORS_XY(x, y);
  //---------------------------------------
  if (x < params->width && y < params->height) 
  {
  
     //-----------------------
     float2 fragCoord = to_float2(x, y); 
     float2 iResolution = to_float2(params->width, params->height);
     float ratio = (float)params->width/(float)params->height;
     float itime=params->itime * params->freq;
	 float4 fragColor = to_float4_s(0.0f);
     //-----------------------

    //Functionality.......
    struct Figur figur;

    figur.pasa = 1.0f;    // steps overlaping airtime
	figur.legmax = 0.89f; // max extention
	figur.leg = 0.89f+0.005f; // actual max length
	figur.armmax = 0.7f;// max extention
	figur.arm = 0.7f +0.012f;// actual max length
	figur.toemax = 1.1f;// max extention toe from hip
	figur.footlift=0.19f; //lift height later multiplied by speed

	setup(itime, &figur);
	//float2 mo = make_float2(iMouse.x,iMouse.y) / iResolution;
    float2 mo = make_float2(params->look[0],params->look[1]);
	float time = 0.0f + itime;
	float3 tot = to_float3_s(0.0f);
 #	if AA > 1
	for (int m = 0; m < AA; m++)
		for (int n = 0; n < AA; n++) {
			// pixel coordinates
			float2 o = make_float2((float)(m), (float)(n)) / (float)(AA) - 0.5f;
			float2 p = (-iResolution + 2.0f * (fragCoord + o)) / iResolution.y;
 # else
			float2 p = (-iResolution + 2.0f * fragCoord) / iResolution.y;
 # endif
			p -=  to_float2( (params->center[0]-0.5f)*2.0f*ratio, (params->center[1]-0.5f)*2.0f);
			p *= params->scale;
			float2 pivot = to_float2(((params->pivot[0]-0.5f)*2.0f*ratio),(params->pivot[1]-0.5f)*2.0f);
			p = spin(p, pivot*params->scale, params->angle, 1.0f);

			// camera	
			float3 ta = timefly(time) + make_float3(0, 0.7f, 0);
			float3 ro = ta + make_float3(-0.5f + 3.5f * _cosf(0.1f * time + 6.0f * mo.x),
				                          2.0f + 2.0f * mo.y,
				                          0.5f + 4.0f * _sinf(0.1f * time + 6.0f * mo.x));
			// camera-to-world transformation
			mat3 ca = setCamera(ro, ta, 0.0f);
			// ray direction
			float3 rd = mat3_multi_f3(ca , normalize(to_float3_aw(swixy(p), 2.5f)));
			// render	
			float3 col = render(ro, rd,itime, iResolution, iChannel0, iChannel1, ratio, params, figur);
			// gamma
			col = pow_f3(col, to_float3_s(0.4545f));
			tot += col;
 # if AA > 1
		}
	tot /= (float)(AA * AA);
 #	endif
	fragColor = to_float4_aw(tot, 1.0f);
    _tex2DVec4Write(dst, x, y, fragColor); 
  }
}
]]

-------------------------------------------------------------------
--       Create
-------------------------------------------------------------------
function Create()
--------------------------------------------
StandardShaderFuseTopControls(); 
--------------------------------------------
  Sep1 = self:AddInput(string.rep("_", 52), "Separator1", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
  })

  --------------- ProceduralWalkAnimation ---------------
  InCenter = self:AddInput("Center", "Center", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INPID_PreviewControl = "CrosshairControl",
    INP_DoNotifyChanged = true,
    })

  InScale = self:AddInput("Scale", "Scale", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    --INPID_PreviewControl = "RectangleControl",
    RCD_LockAspect     = 1,
    RC_DoLockAspect    = true,
    RCID_Center        = "Center", 
    INP_Default = 1.0,
    INP_MinAllowed = 0.1,
    INP_MaxAllowed = 5.0,
    })

  InDebug = self:AddInput("Debug", "Debug", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 1.0,
    --INP_MinScale = 0.0,
    --INP_MaxScale = 5.0,
    --INPID_PreviewControl = "RectangleControl",
    RCD_LockAspect     = 1,
    RC_DoLockAspect    = true,
    RCID_Center = "Center",    
    IC_Visible          = false, 
  })

  InAngle = self:AddInput("Angle", "Angle", {
    LINKID_DataType = "Number",
    INPID_InputControl = "ScrewControl",
    INPID_PreviewControl = "AngleControl",
    --INP_MinAllowed =   0.0,
    INP_MinScale = 0.0,
	INP_MaxScale = 360.0,
    INP_Default = 0.0,
    ACID_Center = "Center",
    --PC_GrabPriority = 1 -- give this a higher priority than the rectangle
    })    
  InPivot = self:AddInput("Pivot", "Pivot", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INPID_PreviewControl = "CrosshairControl",
    CHC_Style = "DiagonalCross",
    PC_GrabPriority = -1,
    })
  InWidgets = self:AddInput("On-Screen Widgets", "OnScreen Widgets", {
    LINKID_DataType = "Number",
    INPID_InputControl = "MultiButtonControl",
    INP_Default = 0,
    INP_Integer = true,
    INP_External        = false,
	INP_Passive         = true,
    INP_DoNotifyChanged = true, 
    MBTNC_ForceButtons = true,
    MBTNC_StretchToFit = true,
    { MBTNC_AddButton = "Show", },
    { MBTNC_AddButton = "Hide", },
  })


  Sep2 = self:AddInput(string.rep("_", 52), "Separator2", {
    LINKID_DataType = "Text",
    INPID_InputControl = "LabelControl",
    INP_External = false,
    INP_Passive = true,
  })

  InFrequency = self:AddInput("Frequency", "Frequency", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 1.0,
    --INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    })

  InStop = self:AddInput("Stop", "Stop", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
	INP_Integer = true,
    INP_DoNotifyChanged = true,
    INP_Default         = 0,
    IC_Visible          = true,
    --INP_External        = false,
  })
  InStartStop = self:AddInput("", "StartStop", {
    { MBTNC_AddButton = "Stop", MBTNCID_AddID = "StopAnimation", },
    { MBTNC_AddButton = "Start", MBTNCID_AddID = "StartAnimation", },
    INPID_DefaultID = "StartAnimation",
    LINKID_DataType = "FuID",
    INPID_InputControl = "MultiButtonIDControl",
    ICD_Width = 1.0,
    MBTNC_StretchToFit = true,
    MBTNC_ForceButtons = true,
    INP_DoNotifyChanged  = true,
    IC_Visible = false,
    --INP_External = false,
  })
  
  
  InActtime = self:AddInput("Acttime", "Acttime", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 0.0,
	  IC_Visible          = false,
    --INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    })
  
  InTimeoffset = self:AddInput("Timeoffset", "Timeoffset", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 0.0,
    --INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    })   

self:BeginControlNest("Parameter", "Par", true, {})

 InLook = self:AddInput("Look","Look", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged = false,
    INP_DefaultX = 0.0,
    INP_DefaultY = 0.0,
    XF_XAxis = -1,
    XF_YAxis = -1,
    XF_XSize = 1,
    XF_YSize = 1,
    XF_Angle = 0,
    XF_EdgeMode = "Black"
    })
  InLookZ = self:AddInput("LookZ", "LookZ", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 0.0,
    --INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    }) 	

  InBall = self:AddInput("Ball", "Ball", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
	INP_Integer = true,
    INP_DoNotifyChanged = true,
    INP_Default         = 1,
    IC_Visible          = true,
    --INP_External        = false,
  })

  InHead = self:AddInput("Head", "Head", {
    LINKID_DataType = "Number",
    INPID_InputControl = "CheckboxControl",
	INP_Integer = true,
    INP_DoNotifyChanged = true,
    INP_Default         = 0,
    IC_Visible          = true,
    --INP_External      = false,
  })

  InGroundTexOff = self:AddInput("Ground texture Offset","GroundTexOff", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged = false,
    INP_DefaultX = 0.0,
    INP_DefaultY = 0.0,
	IC_Visible   = true,
    XF_XAxis = -1,
    XF_YAxis = -1,
    XF_XSize = 1,
    XF_YSize = 1,
    XF_Angle = 0,
    XF_EdgeMode = "Black"
    })
  InGroundTexScale = self:AddInput("Ground Texture Scale", "GroundTexScale", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 1.0,
	IC_Visible   = true,
	INP_MinScale = 0.0,
	INP_MaxScale = 3.0,
    --INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    }) 
  InFigurTexOff = self:AddInput("Figur Texture Offset","FigurTexOff", {
    LINKID_DataType = "Point",
    INPID_InputControl = "OffsetControl",
    INP_DoNotifyChanged = false,
    INP_DefaultX = 0.0,
    INP_DefaultY = 0.0,
	IC_Visible   = true,
    XF_XAxis = -1,
    XF_YAxis = -1,
    XF_XSize = 1,
    XF_YSize = 1,
    XF_Angle = 0,
    XF_EdgeMode = "Black"
    })
  InFigurTexScale = self:AddInput("Figur Texture Scale", "FigurTexScale", {
    LINKID_DataType = "Number",
    INPID_InputControl = "SliderControl",
    INP_Default = 1.0,
	INP_MinScale = 0.0,
	INP_MaxScale = 3.0,
	IC_Visible   = true,
    --INP_MinAllowed = -1.0,
    --INP_MaxAllowed = 1.0,
    }) 



 InRedCH = self:AddInput("Red", "RedCH", {
    ICS_Name            = "Ground Color",
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.3,
    INP_MaxScale        = 0.5,
    CLRC_ShowWheel      = false,
    IC_ControlGroup     = 1,
    IC_ControlID        = 0,
  })
  InGreenCH = self:AddInput("Green", "GreenCH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.3,
    IC_ControlGroup     = 1,
    IC_ControlID        = 1,
  })
  InBlueCH = self:AddInput("Blue", "BlueCH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.3,
    IC_ControlGroup     = 1,
    IC_ControlID        = 2,
  })
  
  InRed2CH = self:AddInput("Red", "Red2CH", {
    ICS_Name            = "Figur Color",
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.6,
    INP_MaxScale        = 1.0,
    CLRC_ShowWheel      = false,
    IC_ControlGroup     = 2,
    IC_ControlID        = 0,
  })
  InGreen2CH = self:AddInput("Green", "Green2CH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.6,
    IC_ControlGroup     = 2,
    IC_ControlID        = 1,
  })
  InBlue2CH = self:AddInput("Blue", "Blue2CH", {
    LINKID_DataType     = "Number",
    INPID_InputControl  = "ColorControl",
    INP_Default         = 0.6,
    IC_ControlGroup     = 2,
    IC_ControlID        = 2,
  })


self:EndControlNest() 

--------------------------------------------
 StandardShaderFuseBottomControls();
--------------------------------------------
------------------- In/Out -----------------
  InImage1 = self:AddInput("Image", "Image", {
    LINKID_DataType = "Image",
    LINK_Main = 1,
	--LINK_Visible = false,
    INP_Required = false
  })
  InImage2 = self:AddInput("Image2", "Image2", {
    LINKID_DataType = "Image",
    LINK_Main = 2,
	--LINK_Visible = false,
    INP_Required = false
  })

  OutImage = self:AddOutput("Output", "Output", {
    LINKID_DataType = "Image",
    LINK_Main = 1,
  })
end 


-------------------------------------------------------------------
--       NotifyChanged
-------------------------------------------------------------------
function NotifyChanged(inp, param, time)


  if inp ~= nil and param ~= nil then
  
    if inp == InCenter then
        -- the center moved, reposition the axis according to the current offset
        nCenterX = param.X
        nCenterY = param.Y
      
        InPivot:SetAttrs({
            PCD_OffsetX = nCenterX - 0.5,
            PCD_OffsetY = nCenterY - 0.5,
            })
           
        InAngle:SetAttrs({
            PCD_OffsetX = (nCenterX - 0.5)/100,
            PCD_OffsetY = (nCenterY - 0.5)/100,
            })
    end
    if inp == InWidgets then  
      if param.Value == 1.0 then
         InCenter:SetAttrs({ PC_Visible = false })
         InAngle:SetAttrs({ PC_Visible = false })
         InPivot:SetAttrs({ PC_Visible = false })
         InScale:SetAttrs({ PC_Visible = false })
      else
         InCenter:SetAttrs({ PC_Visible = true })
         InAngle:SetAttrs({ PC_Visible = true })
         InPivot:SetAttrs({ PC_Visible = true })
         InScale:SetAttrs({ PC_Visible = true })
      end
    end
	
    if inp == InStop then  
      if param.Value == 1 then
	     InActtime:SetAttrs({IC_Visible = true})
	  else
	     InActtime:SetAttrs({IC_Visible = false})
	  end
	end  

	if inp == InLogoSw then  
	  if param.Value == 1 then
		 --authorlogo:SetAttrs({IC_Visible = true})
	  else
		 --authorlogo:SetAttrs({IC_Visible = false})
	  end
	end 
  end
end

-------------------------------------------------------------------
--       Process
-------------------------------------------------------------------
function Process(req)
    local center = InCenter:GetValue(req)
    local angle = -InAngle:GetValue(req).Value/360*3.1415*2
    local debug = InDebug:GetValue(req).Value
    local scale = InScale:GetValue(req).Value
    local freq = InFrequency:GetValue(req).Value
    local framerate = self.Comp:GetPrefs("Comp.FrameFormat.Rate") -- get the frame rate of the comp set in the preferences


    --This creates an image for us to work on.
    local imgattrs = {
        IMG_Document = self.Comp,
        { IMG_Channel = "Red", },
        { IMG_Channel = "Green", },
        { IMG_Channel = "Blue", },
        { IMG_Channel = "Alpha", },
        IMG_Width = Width,
        IMG_Height = Height,
        IMG_XScale = XAspect,
        IMG_YScale = YAspect,
        IMAT_OriginalWidth = realwidth,
        IMAT_OriginalHeight = realheight,
        IMG_Quality = not req:IsQuick(),
        IMG_MotionBlurQuality = not req:IsNoMotionBlur(),
        }
   
    if not req:IsStampOnly() then
        imgattrs.IMG_ProxyScale = 1
    end
   
    if SourceDepth ~= 0 then
        imgattrs.IMG_Depth = SourceDepth
    end
    
    local p = Pixel({R=0,G=0,B=0,A=0})
    
	tex1 = false
	tex2 = false
      if (InImage1:GetValue(req) ~= nil) then
         src1 = InImage1:GetValue(req)
		 tex1 = true
		 InGroundTexOff:SetAttrs({IC_Visible = true})
		 InGroundTexScale:SetAttrs({IC_Visible = true})
		 InRedCH:SetAttrs({IC_Visible = false})
      else
         src1 = Image(imgattrs)
         src1:Fill(p)
		 InGroundTexOff:SetAttrs({IC_Visible = false})
		 InGroundTexScale:SetAttrs({IC_Visible = false})
		 InRedCH:SetAttrs({IC_Visible = true})
      end

      if (InImage2:GetValue(req) ~= nil) then
         src2 = InImage2:GetValue(req)
		 tex2 = true
		 InFigurTexOff:SetAttrs({IC_Visible = true})
		 InFigurTexScale:SetAttrs({IC_Visible = true})
		 InRed2CH:SetAttrs({IC_Visible = false})
		 
      else
         src2 = Image(imgattrs)
         src2:Fill(p)
		 InFigurTexOff:SetAttrs({IC_Visible = false})
		 InFigurTexScale:SetAttrs({IC_Visible = false})
		 InRed2CH:SetAttrs({IC_Visible = true})
      end
	  
  

    local dst = Image {IMG_Like = src1, IMG_DeferAlloc = true}


    if req:IsPreCalc() then
	   --print("\n######################### Precalc ##############################\n")
	   local out = Image({IMG_Like = dst, IMG_NoData = true})
       OutImage:Set(req, out)
	   return
	end



    --StartStop	
    if InStop:GetValue(req).Value == 0 then             
	   _acttime = req.Time + InTimeoffset:GetValue(req).Value
	   startstopsema = 1
	else
	   if startstopsema == 1 then
	      InActtime:SetSource(Number(req.Time),0)
	      startstopsema = 0
	      _acttime = req.Time + InTimeoffset:GetValue(req).Value
	   else
	      _acttime = InActtime:GetValue(req).Value + InTimeoffset:GetValue(req).Value
	   end	
	end

    acttime = _acttime / framerate

    
    --Sep1:SetAttrs({LINKS_Name = "____________ProceduralWalkAnimation______________________",LBLC_LabelColor = 3,})
    
    node = DVIPComputeNode(req, "ProceduralWalkAnimationKernel", ProceduralWalkAnimationKernel, "ProceduralWalkAnimationParams", ProceduralWalkAnimationParams)

    if not pcall(function () 
        params.center[0] = center.X
        params.center[1] = center.Y
	    params.scale = 1/scale
        params.angle = angle
        params.pivot[0] = InPivot:GetValue(req).X
        params.pivot[1] = InPivot:GetValue(req).Y
        params.debug = debug
        params.freq = freq

        params.grdtex      = tex1
		params.fgrtex      = tex2
		params.fgrtexoff   = {InFigurTexOff:GetValue(req).X,InGroundTexOff:GetValue(req).Y}
		params.fgrtexscale = InFigurTexScale:GetValue(req).Value
        params.grdtexoff   = {InGroundTexOff:GetValue(req).X,InGroundTexOff:GetValue(req).Y}
		params.grdtexscale = InGroundTexScale:GetValue(req).Value
		params.ball        = InBall:GetValue(req).Value
		params.head        = InHead:GetValue(req).Value
        params.look        = {InLook:GetValue(req).X,InLook:GetValue(req).Y,InLookZ:GetValue(req).Value}
        params.color       = {InRedCH:GetValue(req).Value, InGreenCH:GetValue(req).Value, InBlueCH:GetValue(req).Value}
		params.color2      = {InRed2CH:GetValue(req).Value, InGreen2CH:GetValue(req).Value, InBlue2CH:GetValue(req).Value}
        
        params.compOrder = src1:IsMask() and 1 or 15
        params.width  = src1.DataWindow:Width()
        params.height = src1.DataWindow:Height()
    
        params.itime = acttime --req.Time / framerate
    
        node:SetParamBlock(params)
    end) then
        params = node:GetParamBlock(ProceduralWalkAnimationParams)
    
        params.center[0] = center.X
        params.center[1] = center.Y
	    params.scale = 1/scale
        params.angle = angle
        params.pivot[0] = InPivot:GetValue(req).X
        params.pivot[1] = InPivot:GetValue(req).Y
        params.debug = debug
        params.freq = freq

        params.grdtex      = tex1
		params.fgrtex      = tex2
		params.fgrtexoff   = {InFigurTexOff:GetValue(req).X,InGroundTexOff:GetValue(req).Y}
		params.fgrtexscale = InFigurTexScale:GetValue(req).Value
        params.grdtexoff   = {InGroundTexOff:GetValue(req).X,InGroundTexOff:GetValue(req).Y}
		params.grdtexscale = InGroundTexScale:GetValue(req).Value
		params.ball        = InBall:GetValue(req).Value
		params.head        = InHead:GetValue(req).Value
        params.look        = {InLook:GetValue(req).X,InLook:GetValue(req).Y,InLookZ:GetValue(req).Value}
        params.color       = {InRedCH:GetValue(req).Value, InGreenCH:GetValue(req).Value, InBlueCH:GetValue(req).Value}
		params.color2      = {InRed2CH:GetValue(req).Value, InGreen2CH:GetValue(req).Value, InBlue2CH:GetValue(req).Value}
        
        params.compOrder = src1:IsMask() and 1 or 15
        params.width  = src1.DataWindow:Width()
        params.height = src1.DataWindow:Height()
        
        params.itime = acttime  --req.Time / framerate
    
        node:SetParamBlock(params)
    
    end

    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_BORDER, TEX_NORMALIZED_COORDS_TRUE)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_WRAP, TEX_NORMALIZED_COORDS_TRUE)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_DUPLICATE, TEX_NORMALIZED_COORDS_TRUE)
     node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR,TEX_ADDRESS_MODE_MIRROR, TEX_NORMALIZED_COORDS_TRUE)
    --node:AddSampler("RowSampler", TEX_FILTER_MODE_LINEAR, TEX_ADDRESS_MODE_CLAMP, TEX_NORMALIZED_COORDS_TRUE)

    node:AddInput("iChannel0", src1)
	node:AddInput("iChannel1", src2)
    node:AddOutput("dst", dst)

    local success = node:RunSession(req)
    if not success then
        dst = nil
        dump(node:GetErrorLog()) -- Fehlerausgabe des DCTL
    end

    OutImage:Set(req, dst)
	collectgarbage();
end

-- **/ "End of LUA CODE"

-- >>> SCHNIPP::SHADERFUSECONTROLS.version="MonumentsAndSites"

function ShaderFuseControls_AuthImg() if FC_AUTHIMG ~= nil and FC_AUTHIMG ~= ""  then self:AddInput('<p align="'..FC_AUTHIMGALIGN..'"><a href="https://github.com/nmbr73/Shadertoys"><img '..FC_AUTHIMG..' /></a></p>',"DctlFuseLogoLabel", {ICS_ControlPage = (FC_AUTHIMGPOS == 2 and 'Info' or nil),IC_ControlPage=(FC_AUTHIMGPOS == 2 and 1 or FC_AUTHIMGPOS),LINKID_DataType = "Text",INPID_InputControl = "LabelControl",LBLC_MultiLine = true,IC_NoLabel = true,IC_NoReset = true,INP_External = false,INP_Passive = true,}) end end
function ShaderFuseControls_InfoBtn() self:AddInput(dctlfuse_name.." Info ...", "DctlFuseInfoButton", {ICS_ControlPage = (FC_INFOBTNPOS == 2 and 'Info' or nil),IC_ControlPage = (FC_INFOBTNPOS == 2 and 1 or FC_INFOBTNPOS),LINKID_DataType = "Text",INPID_InputControl = "ButtonControl",INP_DoNotifyChanged = false,INP_External = false,BTNCS_Execute = 'bmd.openurl("'..(dctlfuse_infourl~=nil and dctlfuse_infourl or 'https://nmbr73.github.io/Shadertoys/Shaders/'..dctlfuse_category..'/'..dctlfuse_name..'.html')..'")'}) end
function ShaderFuseControls_BandImg() if FC_SHOWBRANDIMG then self:AddInput('<p align="center"><a href="https://github.com/nmbr73/Shadertoys"><img height="18" src="data:image/png;base64,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" /></a></p>', "DctlFuseBrandLabel",{ IC_ControlPage = -1 ,LINKID_DataType = "Text",INPID_InputControl = "LabelControl",LBLC_MultiLine = true,IC_NoLabel = true,IC_NoReset = true,INP_External = false,INP_Passive = true,}) end end

function ShaderFuseControls_InfoTxt()
  self:AddInput('<p align="'..FC_INFOTXTALIGN ..'">'
    ..'Shadertoy <a href="https://www.shadertoy.com/view/'..shadertoy_id..'" style="color:white; text-decoration:none; ">'..shadertoy_name..'</a> by <a href="https://www.shadertoy.com/user/'..shadertoy_author..'" style="color:yellow; text-decoration:none; ">'..shadertoy_author..'</a><br />'
    ..'<span style="color:#ff6060; ">'..(shadertoy_license == "" and '&copy; '..shadertoy_author..' (CC BY-NC-SA 3.0)' or shadertoy_license)..'</span><br />'
    ..'DCTLified and DaFused by <a href="'..(dctlfuse_authorurl==nil and "https://nmbr73.github.io/Shadertoys/" or dctlfuse_authorurl)..'" style="color:yellow; text-decoration:none; ">'..dctlfuse_author..'</a><br />'
    ..'<span style="color:#4060ff; ">'..(FC_VERSIONNO==nil and '' or 'Version '..FC_VERSIONNO)..(FC_VERSIONNO~=nil and FC_VERSIONDATE~=nil and ' - ' or '')..(FC_VERSIONDATE==nil and '' or FC_VERSIONDATE)..(FC_VERSIONNO~=nil and FC_VERSIONDATE~=nil and '<br />' or '')..'</span></p>'
    ,"DctlFuseInfoLabel", {ICS_ControlPage =(FC_INFOTXTPOS == 2 and 'Info' or nil),IC_ControlPage = (FC_INFOTXTPOS == 2 and 1 or FC_INFOTXTPOS),LINKID_DataType="Text",INPID_InputControl="LabelControl",LBLC_MultiLine=true,IC_NoLabel=true,IC_NoReset=true,INP_External=false,INP_Passive=true})
end

function StandardShaderFuseTopControls()
  if FC_ITEMORDER         == nil then FC_ITEMORDER       = {ShaderFuseControls_InfoTxt,ShaderFuseControls_BandImg,ShaderFuseControls_InfoBtn,ShaderFuseControls_AuthImg} end
  if FC_SHOWBRANDIMG      == nil then FC_SHOWBRANDIMG    = true                  end
  if FC_AUTHBASEDLAYOUT   == nil then FC_AUTHBASEDLAYOUT = true                  end
  if FC_INFOBTNPOS        == nil then FC_INFOBTNPOS      = 2                     end
  if FC_INFOTXTPOS        == nil then FC_INFOTXTPOS      = 2                     end
  if FC_INFOTXTALIGN      == nil then FC_INFOTXTALIGN    = 'center'              end
  if FC_AUTHIMGPOS        == nil then FC_AUTHIMGPOS      = 2                     end
  if FC_AUTHIMGALIGN      == nil then FC_AUTHIMGALIGN    = 'center'              end
  if FC_VERSIONNO         == nil then FC_VERSIONNO       = dctlfuse_versionNo    end
  if FC_VERSIONDATE       == nil then FC_VERSIONDATE     = dctlfuse_versionDate  end
  if FC_AUTHIMG           == nil then FC_AUTHIMG         = ''                    end
  if dctlfuse_authorlogo  ~= nil then FC_AUTHIMG         = dctlfuse_authorlogo   end
  if FC_AUTHBASEDLAYOUT then
    if dctlfuse_author=='JiPi' then
    --FC_SHOWBRANDIMG=false
      FC_ITEMORDER  = {ShaderFuseControls_BandImg, ShaderFuseControls_AuthImg,ShaderFuseControls_InfoBtn,ShaderFuseControls_InfoTxt}
      FC_INFOBTNPOS = 1; FC_AUTHIMGPOS = -1; FC_AUTHIMGALIGN = 'center'; FC_INFOTXTPOS = 1; FC_INFOTXTALIGN = 'center'
    elseif dctlfuse_author=='nmbr73' then
      FC_ITEMORDER = {ShaderFuseControls_InfoBtn,ShaderFuseControls_BandImg,ShaderFuseControls_InfoTxt,ShaderFuseControls_AuthImg}
      FC_INFOBTNPOS = -1; FC_AUTHIMGPOS = 1; FC_AUTHIMGALIGN = 'right'; FC_INFOTXTPOS = 1; FC_INFOTXTALIGN = 'left'
    end
  end
end

function StandardShaderFuseBottomControls()
  if FC_INFOBTNPOS == 1 or FC_INFOTXTPOS == 1 or FC_AUTHIMGPOS==1 then
    self:AddInput( '<br />',"DctlFuseSeparatorLabel",{LINKID_DataType="Text",INPID_InputControl="LabelControl",LBLC_MultiLine=true,IC_NoLabel=true,IC_NoReset=true,INP_External=false,INP_Passive=true})
  end
  FC_ITEMORDER[1](); FC_ITEMORDER[2](); FC_ITEMORDER[3](); FC_ITEMORDER[4]();
end
-- <<< SCHNAPP::SHADERFUSECONTROLS
-- */